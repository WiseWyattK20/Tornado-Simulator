<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tornado Simulator — Supercell Culled</title>
<style>
  html,body{height:100%;margin:0;background:#333}
  body{font-family:Inter,Arial,sans-serif;overflow:hidden}
  #controls{
    position:absolute;left:12px;top:12px;z-index:60;background:rgba(255,255,255,0.96);
    padding:10px;border-radius:8px;width:300px;box-shadow:0 10px 30px rgba(0,0,0,0.25)
  }
  #controls input[type=range]{width:200px}
  #controls label{font-size:13px}
  button{margin-top:8px;padding:6px 10px}
  #perfBadge{position:absolute;right:12px;top:12px;z-index:60;background:rgba(255,255,255,0.9);padding:6px 8px;border-radius:6px;font-size:13px}
</style>
</head>
<body>
<div id="controls">
  <label>Wind Speed (mph): <strong id="windValue">80</strong></label><br>
  <input id="windSlider" type="range" min="10" max="200" value="80"><br>

  <label>Tornado Speed (mph): <strong id="speedValue">10</strong></label><br>
  <input id="speedSlider" type="range" min="1" max="90" value="10"><br>

  <label>Tornado Width: <strong id="widthValue">60</strong></label><br>
  <input id="widthSlider" type="range" min="10" max="300" value="60"><br>

  <label>Performance Mode (auto):</label>
  <input id="perfToggle" type="checkbox" checked><br>

  <button id="startBtn">Start (drop funnel)</button>
  <button id="resetBtn">Reset</button>
</div>
<div id="perfBadge">Perf: <span id="perfState">AUTO</span></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script>
/*
  Culled supercell — everything else unchanged:
  - Realistic funnel (rings + particle swirl)
  - Wall cloud base (low)
  - Ground scour overlay
  - Procedural damage, debris spawn & ingestion
  - Lightning, camera follow, performance mode
*/

let scene, camera, renderer;
let tornado, innerPoints;
const tornadoStart = { x:-400, y:260, z:0 };
let debrisGroup;
let houses = [], trees = [], debris = [];
let wallCloud;
let animating = false, dropping = false;

let windSpeed = 80;
let tornadoSpeedMph = 10;
let tornadoWidth = 60;
let tornadoWindRadius = 200;
const damageThreshold = 75;
let performanceMode = true;
let lastTime = performance.now();
let lightningTimer = 0;

// UI
const windSlider = document.getElementById('windSlider');
const speedSlider = document.getElementById('speedSlider');
const widthSlider = document.getElementById('widthSlider');
const windValue = document.getElementById('windValue');
const speedValue = document.getElementById('speedValue');
const widthValue = document.getElementById('widthValue');
const perfToggle = document.getElementById('perfToggle');
const perfState = document.getElementById('perfState');

windSlider.oninput = () => { windSpeed = Number(windSlider.value); windValue.textContent = windSlider.value; updateWindRadius(); paintScour(); };
speedSlider.oninput = () => { tornadoSpeedMph = Number(speedSlider.value); speedValue.textContent = speedSlider.value; };
widthSlider.oninput = () => { tornadoWidth = Number(widthSlider.value); widthValue.textContent = widthSlider.value; updateWindRadius(); adjustTornadoScale(); paintScour(); };
perfToggle.onchange = () => { performanceMode = perfToggle.checked; applyPerformanceMode(); rebuildScene(); };

document.getElementById('startBtn').onclick = startDrop;
document.getElementById('resetBtn').onclick = resetAll;

// auto perf detection
(function detectAutoPerf(){
  const mem = navigator.deviceMemory || 4;
  const ua = navigator.userAgent || '';
  const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(ua);
  performanceMode = (mem <= 2 || isMobile);
  perfToggle.checked = performanceMode;
  perfState.textContent = performanceMode ? 'ON' : 'OFF';
})();

// --- THREE init ---
init();
animate();

function init(){
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x2b2b2f);
  scene.fog = new THREE.Fog(0x2b2b2f, 800, 4200);

  camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 6000);
  camera.position.set(0,240,480);
  camera.lookAt(0,60,0);

  renderer = new THREE.WebGLRenderer({ antialias: !performanceMode });
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(performanceMode ? Math.min(window.devicePixelRatio || 1, 1) : Math.min(window.devicePixelRatio || 1.5, 2));
  document.body.appendChild(renderer.domElement);

  window.addEventListener('resize', () => {
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  // lighting
  const hemi = new THREE.HemisphereLight(0x6b6d73, 0x222222, 0.7); scene.add(hemi);
  const sun = new THREE.DirectionalLight(0xddddff, 0.45); sun.position.set(-200,300,160); scene.add(sun);

  // ground
  const groundMat = new THREE.MeshPhongMaterial({ color: 0x334f33 });
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(3000,3000), groundMat);
  ground.rotation.x = -Math.PI/2;
  scene.add(ground);

  // scour overlay
  createScourCanvas();

  // tornado visuals
  createTornadoVisual();

  // wall cloud (low localized base)
  createWallCloud();

  // debris group
  debrisGroup = new THREE.Group();
  scene.add(debrisGroup);

  applyPerformanceMode();
  rebuildScene();
  updateWindRadius();
  paintScour();
}

// Tornado visuals: stacked rings + inner points
function createTornadoVisual(){
  tornado = new THREE.Group();
  const rings = performanceMode ? 20 : 36;
  for(let i=0;i<rings;i++){
    const R = Math.max(1, 38 - i*1.05);
    const tube = 1.6;
    const geo = new THREE.TorusGeometry(R, tube, 8, 48);
    geo.rotateX(Math.PI/2);
    const y = (rings - i) * 5;
    geo.translate(0, y, 0);
    const mat = new THREE.MeshStandardMaterial({ color: 0x222225, transparent:true, opacity: 0.6 - (i/rings)*0.45, side: THREE.DoubleSide });
    const ring = new THREE.Mesh(geo, mat);
    ring.userData.i = i;
    tornado.add(ring);
  }
  // inner points
  const pCount = performanceMode ? 400 : 1200;
  const pos = new Float32Array(pCount*3);
  for(let i=0;i<pCount;i++){
    pos[i*3+0] = (Math.random()-0.5)*20;
    pos[i*3+1] = Math.random()*200;
    pos[i*3+2] = (Math.random()-0.5)*20;
  }
  const g = new THREE.BufferGeometry();
  g.setAttribute('position', new THREE.BufferAttribute(pos, 3));
  const pm = new THREE.PointsMaterial({ size: performanceMode ? 1.1 : 1.8, color:0xaaaaaa, transparent:true, opacity:0.95 });
  innerPoints = new THREE.Points(g, pm);
  tornado.add(innerPoints);

  tornado.position.set(tornadoStart.x, tornadoStart.y, tornadoStart.z);
  scene.add(tornado);
}

// Wall cloud (kept low so it won't block view)
function createWallCloud(){
  if(wallCloud) scene.remove(wallCloud);
  wallCloud = new THREE.Group();
  const g = new THREE.CylinderGeometry(120, 220, 40, 18, 1, true);
  g.translate(0,20,0);
  const mat = new THREE.MeshLambertMaterial({ color: 0x1d1d20, transparent:true, opacity:0.42, side: THREE.DoubleSide });
  const mesh = new THREE.Mesh(g, mat);
  wallCloud.add(mesh);
  wallCloud.position.set(tornadoStart.x, 100, tornadoStart.z);
  scene.add(wallCloud);
}

// Scour overlay (canvas)
let scourCanvas, scourTexture, scourMesh;
function createScourCanvas(){
  const SIZE = 2048;
  scourCanvas = document.createElement('canvas');
  scourCanvas.width = SIZE; scourCanvas.height = SIZE;
  scourTexture = new THREE.CanvasTexture(scourCanvas);
  scourTexture.wrapS = scourTexture.wrapT = THREE.ClampToEdgeWrapping;
  const mat = new THREE.MeshBasicMaterial({ map: scourTexture, transparent:true, opacity:1, depthWrite:false });
  const plane = new THREE.PlaneGeometry(3000,3000);
  scourMesh = new THREE.Mesh(plane, mat);
  scourMesh.rotation.x = -Math.PI/2;
  scourMesh.position.y = 0.02;
  scene.add(scourMesh);
  paintScour();
}

function paintScour(){
  if(!scourCanvas) return;
  const ctx = scourCanvas.getContext('2d');
  ctx.clearRect(0,0,scourCanvas.width, scourCanvas.height);
  const mapSize = 3000;
  const cx = (scourCanvas.width/2) + (tornado.position.x / mapSize) * scourCanvas.width;
  const cy = (scourCanvas.height/2) - (tornado.position.z / mapSize) * scourCanvas.height;
  const baseRadius = Math.max(120, (tornadoWindRadius / mapSize) * scourCanvas.width * (1 + windSpeed / 140));
  const innerAlpha = Math.min(0.95, (windSpeed / 220) * 1.6);
  const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, baseRadius);
  grad.addColorStop(0, `rgba(59,34,8,${innerAlpha})`);
  grad.addColorStop(0.35, `rgba(90,58,29,${innerAlpha*0.66})`);
  grad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,scourCanvas.width, scourCanvas.height);
  scourTexture.needsUpdate = true;
}

// Rebuild scene (houses, trees, ambient debris)
function rebuildScene(){
  houses.forEach(h=>scene.remove(h)); houses = [];
  trees.forEach(t=>scene.remove(t)); trees = [];
  debris.forEach(d=>debrisGroup.remove(d)); debris = [];

  const houseCount = performanceMode ? 8 : 18;
  const treeCount = performanceMode ? 24 : 70;
  const ambientDebris = performanceMode ? 60 : 240;

  // Houses (bricks + roof tiles)
  for(let i=0;i<houseCount;i++){
    const house = new THREE.Group();
    const baseGroup = new THREE.Group();
    const W = 18, H = 10, D = 14;
    const brick = 3;
    const xs = Math.max(2, Math.floor(W/brick));
    const zs = Math.max(2, Math.floor(D/brick));
    for(let xi=0; xi<xs; xi++){
      for(let zi=0; zi<zs; zi++){
        const b = new THREE.Mesh(new THREE.BoxGeometry(brick, H-2, brick), new THREE.MeshStandardMaterial({ color: 0xb36a42 }));
        b.position.set((xi - (xs-1)/2) * brick, (H/2)-1, (zi - (zs-1)/2) * brick);
        baseGroup.add(b);
      }
    }
    house.add(baseGroup);

    const roof = new THREE.Group();
    const tx = 6, tz = 4;
    for(let ix=0; ix<tx; ix++){
      for(let iz=0; iz<tz; iz++){
        const tile = new THREE.Mesh(new THREE.BoxGeometry(4,1.8,6), new THREE.MeshStandardMaterial({ color: 0x5e1515 }));
        tile.position.set((ix-(tx-1)/2)*4.2, H+1.6 + Math.random()*0.2, (iz-(tz-1)/2)*6.2);
        roof.add(tile);
      }
    }
    house.add(roof);
    house.userData = { baseGroup, roofGroup: roof, damageAccum: 0 };
    house.position.set((Math.random()-0.5)*1400, 0, (Math.random()-0.5)*1400);
    scene.add(house);
    houses.push(house);
  }

  // Trees
  for(let i=0;i<treeCount;i++){
    const tree = new THREE.Group();
    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.9,1.1,5,6), new THREE.MeshStandardMaterial({ color: 0x6b3f2a }));
    trunk.position.y = 2.5; tree.add(trunk);
    const foliage = new THREE.Group();
    const layers = performanceMode ? 2 : 4;
    for(let l=0;l<layers;l++){
      const cone = new THREE.Mesh(new THREE.ConeGeometry(3 + l*1.1, 6 + l*1.0, 8), new THREE.MeshStandardMaterial({ color: 0x1f7a1f }));
      cone.position.y = 6 + l*2.6; foliage.add(cone);
    }
    tree.add(foliage);
    tree.userData = { trunk, foliageGroup: foliage, damageAccum: 0 };
    tree.position.set((Math.random()-0.5)*1400, 0, (Math.random()-0.5)*1400);
    scene.add(tree);
    trees.push(tree);
  }

  // Ambient debris
  for(let i=0;i<ambientDebris;i++){
    const s = 0.6 + Math.random()*2.4;
    const g = new THREE.BoxGeometry(s, Math.max(0.2,s*0.35), s*0.7);
    const m = new THREE.MeshStandardMaterial({ color: 0x7b7b7b });
    const p = new THREE.Mesh(g,m);
    p.position.set((Math.random()-0.5)*900, Math.random()*120 + 5, (Math.random()-0.5)*900);
    p.userData = { velocity: new THREE.Vector3(), life: undefined };
    debrisGroup.add(p);
    debris.push(p);
  }

  adjustTornadoScale();
  updateWindRadius();
  paintScour();
}

// Spawn debris from mesh
function spawnDebrisFromMesh(mesh, count=3){
  const pos = new THREE.Vector3();
  mesh.getWorldPosition(pos);
  for(let i=0;i<count;i++){
    const s = 0.5 + Math.random()*2.2;
    const g = new THREE.BoxGeometry(s, Math.max(0.2,s*0.3), s*0.6);
    const m = mesh.material ? mesh.material.clone() : new THREE.MeshStandardMaterial({ color:0x7b7b7b });
    const p = new THREE.Mesh(g,m);
    p.position.copy(pos).add(new THREE.Vector3((Math.random()-0.5)*6, 2 + Math.random()*3, (Math.random()-0.5)*6));
    p.userData = { velocity: new THREE.Vector3((Math.random()-0.5)*2, 2 + Math.random()*3, (Math.random()-0.5)*2), life: 8 + Math.random()*8 };
    debrisGroup.add(p); debris.push(p);
    if(debris.length > (performanceMode ? 800 : 2000)) break;
  }
}

// Remove child and spawn debris
function removeChildAndSpawn(parent, child){
  if(!parent || !child) return;
  parent.remove(child);
  spawnDebrisFromMesh(child, 3 + Math.floor(Math.random()*4));
}

// Damage & physics
function applyDamageAndPhysics(delta){
  const center = new THREE.Vector3(tornado.position.x, 60, tornado.position.z);

  houses.forEach(h => {
    const dist = h.position.distanceTo(center);
    const prox = Math.max(0, 1 - dist / tornadoWindRadius);
    if(windSpeed >= damageThreshold && prox > 0.02){
      const intensity = ((windSpeed - damageThreshold) / (200 - damageThreshold + 0.0001)) * prox;
      h.userData.damageAccum = (h.userData.damageAccum || 0) + intensity * delta * (1 + Math.random()*0.8);
      if(h.userData.damageAccum > 0.5){
        const roof = h.userData.roofGroup;
        if(roof && roof.children.length > 0){
          const idx = Math.floor(Math.random() * roof.children.length);
          const tile = roof.children[idx];
          removeChildAndSpawn(roof, tile);
        } else {
          const base = h.userData.baseGroup;
          if(base && base.children.length > 0){
            const idx = Math.floor(Math.random() * base.children.length);
            const brick = base.children[idx];
            removeChildAndSpawn(base, brick);
          }
        }
        h.userData.damageAccum = Math.random()*0.25;
      }
    } else {
      h.userData.damageAccum = Math.max(0, (h.userData.damageAccum || 0) - delta * 0.15);
    }
  });

  trees.forEach(t => {
    const dist = t.position.distanceTo(center);
    const prox = Math.max(0, 1 - dist / (tornadoWindRadius * 0.95));
    if(windSpeed >= damageThreshold && prox > 0.02){
      const intensity = ((windSpeed - damageThreshold) / (200 - damageThreshold + 0.0001)) * prox;
      t.userData.damageAccum = (t.userData.damageAccum || 0) + intensity * delta * (1 + Math.random()*0.6);
      if(t.userData.damageAccum > 0.45){
        const fol = t.userData.foliageGroup;
        if(fol && fol.children.length > 0){
          const idx = Math.floor(Math.random() * fol.children.length);
          const piece = fol.children[idx];
          removeChildAndSpawn(fol, piece);
        } else {
          const trunk = t.userData.trunk;
          if(trunk && trunk.parent) removeChildAndSpawn(t, trunk);
        }
        t.userData.damageAccum = Math.random()*0.2;
      }
    } else {
      t.userData.damageAccum = Math.max(0, (t.userData.damageAccum || 0) - delta * 0.14);
    }
  });

  // debris physics
  const tNow = performance.now() * 0.001;
  const maxPull = tornadoWindRadius * 1.6;
  for(let i=debris.length-1;i>=0;i--){
    const p = debris[i];
    if(p.userData.life !== undefined){
      p.userData.life -= delta;
      if(p.userData.life <= 0){ debrisGroup.remove(p); debris.splice(i,1); continue; }
    }
    const dir = new THREE.Vector3().subVectors(center, p.position);
    const dist = dir.length();
    if(dist > maxPull){
      p.userData.velocity.y -= 9.8 * 0.018 * delta;
      p.userData.velocity.multiplyScalar(0.995);
      p.position.addScaledVector(p.userData.velocity, delta * 60);
      continue;
    }
    const radial = dir.clone().normalize();
    const tangential = new THREE.Vector3(-radial.z, 0, radial.x);
    const proximity = Math.max(0, 1 - dist / maxPull);
    const pull = 0.8 * (windSpeed / 140) * proximity;
    const swirl = 0.45 * (1 + proximity * 1.8) * (windSpeed / 160);
    const up = 0.6 * (1 + proximity) * (windSpeed / 200);
    const wobble = Math.sin(tNow * 6 + i) * 0.02;
    p.userData.velocity.addScaledVector(radial, pull * delta * 200);
    p.userData.velocity.addScaledVector(tangential, swirl * delta * 200);
    p.userData.velocity.y += (up + wobble) * delta * 60;
    p.userData.velocity.multiplyScalar(0.993);
    p.position.addScaledVector(p.userData.velocity, delta * 60);
    if(dist < 8){
      if(Math.random() < 0.25) p.userData.life = 3 + Math.random()*4;
      else { debrisGroup.remove(p); debris.splice(i,1); }
    }
  }
}

// Lightning (from wall cloud area)
function maybeLightning(delta){
  lightningTimer -= delta;
  if(lightningTimer <= 0){
    lightningTimer = 0.6 + Math.random()*3.2;
    if(Math.random() < 0.45) doLightning();
  }
}
function doLightning(){
  const origin = new THREE.Vector3(
    tornado.position.x + (Math.random()-0.5)*160,
    tornado.position.y + 80 + Math.random()*80,
    tornado.position.z + (Math.random()-0.5)*160
  );
  const target = new THREE.Vector3(
    tornado.position.x + (Math.random()-0.5)*600,
    0,
    tornado.position.z + (Math.random()-0.5)*600
  );
  const seg = 8; const pts = [];
  for(let i=0;i<=seg;i++){
    const t = i/seg;
    const y = origin.y * (1 - t);
    const x = origin.x + (target.x - origin.x) * t + (Math.random()-0.5)*40*(1-t);
    const z = origin.z + (target.z - origin.z) * t + (Math.random()-0.5)*40*(1-t);
    pts.push(new THREE.Vector3(x,y,z));
  }
  const geo = new THREE.BufferGeometry().setFromPoints(pts);
  const mat = new THREE.LineBasicMaterial({ color:0xffffff, linewidth:2 });
  const bolt = new THREE.Line(geo, mat);
  scene.add(bolt);
  const flash = new THREE.PointLight(0xffffff, 2.6, 1200);
  flash.position.copy(target).add(new THREE.Vector3(0,40,0));
  scene.add(flash);
  setTimeout(()=>{ scene.remove(bolt); scene.remove(flash); }, 90 + Math.random()*150);
}

// Funnel drop
function startDrop(){
  if(dropping || animating) return;
  dropping = true; animating = false;
  tornado.position.set(tornadoStart.x, tornadoStart.y, tornadoStart.z);
  const duration = 1100, start = performance.now(), fromY = tornadoStart.y, toY = 60;
  (function step(now){
    const t = Math.min(1, (now - start) / duration);
    const e = 1 - Math.pow(1 - t, 3);
    tornado.position.y = fromY * (1 - e) + toY * e;
    tornado.children.forEach((r, idx) => r.rotation.y += 0.03 + idx*0.001);
    if(t < 1) requestAnimationFrame(step);
    else { dropping = false; animating = true; }
  })(performance.now());
}

// Reset
function resetAll(){
  animating = false; dropping = false;
  tornado.position.set(tornadoStart.x, tornadoStart.y, tornadoStart.z);
  tornado.rotation.set(0,0,0);
  houses.forEach(h => scene.remove(h)); houses = [];
  trees.forEach(t => scene.remove(t)); trees = [];
  debris.forEach(d => debrisGroup.remove(d)); debris = [];
  const ctx = scourCanvas.getContext('2d'); ctx.clearRect(0,0,scourCanvas.width, scourCanvas.height);
  scourTexture.needsUpdate = true;
  rebuildScene();
}

// Speed mapping (mph -> units/sec)
function mphToUnitsPerSec(mph){ return mph * 0.02; }

// Update radius and adjust visuals
function updateWindRadius(){ tornadoWindRadius = Math.max(80, tornadoWidth * 2.2 * (1 + windSpeed / 140)); }
function adjustTornadoScale(){
  const s = Math.max(0.5, Math.min(3.2, tornadoWidth / 50));
  tornado.scale.set(s,1,s);
  if(innerPoints){
    const pos = innerPoints.geometry.attributes.position.array;
    for(let i=0;i<pos.length/3;i++){
      pos[i*3+0] = (Math.random()-0.5) * 26 * s;
      pos[i*3+1] = Math.random() * 220;
      pos[i*3+2] = (Math.random()-0.5) * 26 * s;
    }
    innerPoints.geometry.attributes.position.needsUpdate = true;
  }
}

// Rebuild helper wrapper (clean)
function rebuildScene(){
  // clear existing
  houses.forEach(h=>scene.remove(h)); houses = [];
  trees.forEach(t=>scene.remove(t)); trees = [];
  debris.forEach(d=>debrisGroup.remove(d)); debris = [];

  const houseCount = performanceMode ? 8 : 18;
  const treeCount = performanceMode ? 24 : 70;
  const ambientDebris = performanceMode ? 60 : 240;

  // Houses
  for(let i=0;i<houseCount;i++){
    const house = new THREE.Group();
    const baseGroup = new THREE.Group();
    const W = 18, H = 10, D = 14;
    const brick = 3;
    const xs = Math.max(2, Math.floor(W/brick));
    const zs = Math.max(2, Math.floor(D/brick));
    for(let xi=0; xi<xs; xi++){
      for(let zi=0; zi<zs; zi++){
        const b = new THREE.Mesh(new THREE.BoxGeometry(brick, H-2, brick), new THREE.MeshStandardMaterial({ color: 0xb36a42 }));
        b.position.set((xi - (xs-1)/2) * brick, (H/2)-1, (zi - (zs-1)/2) * brick);
        baseGroup.add(b);
      }
    }
    house.add(baseGroup);
    const roof = new THREE.Group();
    const tx = 6, tz = 4;
    for(let ix=0; ix<tx; ix++){
      for(let iz=0; iz<tz; iz++){
        const tile = new THREE.Mesh(new THREE.BoxGeometry(4,1.8,6), new THREE.MeshStandardMaterial({ color: 0x5e1515 }));
        tile.position.set((ix-(tx-1)/2)*4.2, H+1.6 + Math.random()*0.2, (iz-(tz-1)/2)*6.2);
        roof.add(tile);
      }
    }
    house.add(roof);
    house.userData = { baseGroup, roofGroup: roof, damageAccum: 0 };
    house.position.set((Math.random()-0.5)*1400, 0, (Math.random()-0.5)*1400);
    scene.add(house);
    houses.push(house);
  }

  // Trees
  for(let i=0;i<treeCount;i++){
    const tree = new THREE.Group();
    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.9,1.1,5,6), new THREE.MeshStandardMaterial({ color: 0x6b3f2a }));
    trunk.position.y = 2.5; tree.add(trunk);
    const foliage = new THREE.Group();
    const layers = performanceMode ? 2 : 4;
    for(let l=0;l<layers;l++){
      const cone = new THREE.Mesh(new THREE.ConeGeometry(3 + l*1.1, 6 + l*1.0, 8), new THREE.MeshStandardMaterial({ color: 0x1f7a1f }));
      cone.position.y = 6 + l*2.6; foliage.add(cone);
    }
    tree.add(foliage);
    tree.userData = { trunk, foliageGroup: foliage, damageAccum: 0 };
    tree.position.set((Math.random()-0.5)*1400, 0, (Math.random()-0.5)*1400);
    scene.add(tree);
    trees.push(tree);
  }

  // ambient debris
  for(let i=0;i<ambientDebris;i++){
    const s = 0.6 + Math.random()*2.4;
    const g = new THREE.BoxGeometry(s, Math.max(0.2,s*0.35), s*0.7);
    const m = new THREE.MeshStandardMaterial({ color: 0x7b7b7b });
    const p = new THREE.Mesh(g,m);
    p.position.set((Math.random()-0.5)*900, Math.random()*120 + 5, (Math.random()-0.5)*900);
    p.userData = { velocity: new THREE.Vector3(), life: undefined };
    debrisGroup.add(p);
    debris.push(p);
  }

  adjustTornadoScale();
  updateWindRadius();
  paintScour();
}

// Animation loop
function animate(){
  requestAnimationFrame(animate);
  const now = performance.now();
  const delta = Math.min(0.05, (now - lastTime) / 1000);
  lastTime = now;

  if(animating && !dropping){
    const unitsPerSec = mphToUnitsPerSec(tornadoSpeedMph);
    tornado.position.x += unitsPerSec * delta * 60;
  }

  const ringSpeed = 0.04 + (windSpeed / 240) * 0.5;
  tornado.children.forEach((r, idx) => r.rotation.y += ringSpeed * (1 + idx*0.002));
  if(innerPoints) innerPoints.rotation.y += 0.05 + (windSpeed / 500);

  wallCloud.position.lerp(new THREE.Vector3(tornado.position.x, 90, tornado.position.z), 0.06);

  paintScour();

  if(animating){
    applyDamageAndPhysics(delta);
  } else {
    for(let i=debris.length-1;i>=0;i--){
      const p = debris[i];
      p.userData.velocity.y -= 9.8 * 0.018 * delta;
      p.userData.velocity.multiplyScalar(0.995);
      p.position.addScaledVector(p.userData.velocity, delta * 60);
      if(p.userData.life !== undefined){
        p.userData.life -= delta;
        if(p.userData.life <= 0){ debrisGroup.remove(p); debris.splice(i,1); }
      }
    }
  }

  maybeLightning(delta);

  // gentle camera follow
  camera.position.x += (tornado.position.x + 120 - camera.position.x) * 0.03;
  camera.position.z += (tornado.position.z + 360 - camera.position.z) * 0.03;
  camera.lookAt(new THREE.Vector3(tornado.position.x, 60, tornado.position.z));

  renderer.render(scene, camera);
}

// initial update
updateWindRadius();
adjustTornadoScale();
paintScour();

</script>
</body>
</html>
