<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tornado Simulator — GitHub Friendly (cloud toggle)</title>
<style>
  html,body{height:100%;margin:0;background:#2b2b2f}
  body{font-family:Arial,Helvetica,sans-serif;overflow:hidden}
  #controls{
    position:absolute;left:12px;top:12px;z-index:60;background:rgba(255,255,255,0.96);
    padding:10px;border-radius:8px;width:320px;box-shadow:0 10px 30px rgba(0,0,0,0.25)
  }
  #controls input[type=range]{width:210px}
  #controls label{font-size:13px}
  button{margin-top:8px;padding:6px 10px}
  #perfBadge{position:absolute;right:12px;top:12px;z-index:60;background:rgba(255,255,255,0.9);padding:6px 8px;border-radius:6px;font-size:13px}
  .small { font-size:12px; color:#333; }
</style>
</head>
<body>
<div id="controls" aria-label="Simulator controls">
  <label>Wind Strength (mph): <strong id="windValue">80</strong></label><br>
  <input id="windSlider" type="range" min="10" max="200" value="80"><br>

  <label>Tornado Speed (mph): <strong id="speedValue">10</strong></label><br>
  <input id="speedSlider" type="range" min="1" max="90" value="10"><br>

  <label>Tornado Width: <strong id="widthValue">60</strong></label><br>
  <input id="widthSlider" type="range" min="10" max="300" value="60"><br>

  <label>Performance Mode (auto):</label>
  <input id="perfToggle" type="checkbox" checked><br>

  <label>Show Storm Clouds:</label>
  <input id="cloudsToggle" type="checkbox" checked class="small"><span class="small"> (uncheck to remove clouds)</span><br>

  <button id="startBtn">Start (drop funnel)</button>
  <button id="resetBtn">Reset</button>
</div>

<div id="perfBadge">Perf: <span id="perfState">AUTO</span></div>

<!-- three.js from HTTPS CDN -->
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', () => {
  // -------------------------
  // Config / State
  // -------------------------
  let scene, camera, renderer;
  let tornado, innerPoints;
  const tornadoStart = { x: -400, y: 260, z: 0 };
  let debrisGroup;
  let houses = [], trees = [], debris = [];
  let wallCloud = null;
  let stormClouds = []; // optional clouds
  let cloudsEnabled = true;

  let animating = false, dropping = false;
  let windStrength = 80;         // influences wind field — NOT tornado translation
  let tornadoSpeedMph = 10;      // translation speed (mph -> scene units)
  let tornadoWidth = 60;         // visual width and wind radius
  let tornadoWindRadius = 200;   // computed
  const damageThreshold = 75;    // damage applies only while windStrength >= this
  let performanceMode = true;
  let lastTime = performance.now();
  let lightningTimer = 0;

  // UI references
  const windSlider = document.getElementById('windSlider');
  const speedSlider = document.getElementById('speedSlider');
  const widthSlider = document.getElementById('widthSlider');
  const windValue = document.getElementById('windValue');
  const speedValue = document.getElementById('speedValue');
  const widthValue = document.getElementById('widthValue');
  const perfToggle = document.getElementById('perfToggle');
  const perfState = document.getElementById('perfState');
  const cloudsToggle = document.getElementById('cloudsToggle');

  // Wire UI events (no inline attributes, GitHub Pages–friendly)
  windSlider.addEventListener('input', () => {
    windStrength = Number(windSlider.value);
    windValue.textContent = windSlider.value;
    updateWindRadius();
    paintScour();
  });
  speedSlider.addEventListener('input', () => {
    tornadoSpeedMph = Number(speedSlider.value);
    speedValue.textContent = speedSlider.value;
  });
  widthSlider.addEventListener('input', () => {
    tornadoWidth = Number(widthSlider.value);
    widthValue.textContent = widthSlider.value;
    updateWindRadius();
    adjustTornadoScale();
    paintScour();
  });
  perfToggle.addEventListener('change', () => {
    performanceMode = perfToggle.checked;
    perfState.textContent = performanceMode ? 'ON' : 'OFF';
    applyPerformanceMode();
    rebuildScene();
  });
  cloudsToggle.addEventListener('change', () => {
    cloudsEnabled = cloudsToggle.checked;
    if (!cloudsEnabled) removeStormClouds();
    else createStormCloudsIfAllowed();
  });
  document.getElementById('startBtn').addEventListener('click', startDrop);
  document.getElementById('resetBtn').addEventListener('click', resetAll);

  // Auto detect performance (simple heuristics)
  (function detectAutoPerf(){
    const mem = navigator.deviceMemory || 4;
    const ua = navigator.userAgent || '';
    const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(ua);
    performanceMode = (mem <= 2 || isMobile);
    perfToggle.checked = performanceMode;
    perfState.textContent = performanceMode ? 'ON' : 'OFF';
    // default: if performanceMode, auto-disable clouds to avoid blocking
    if (performanceMode) {
      cloudsToggle.checked = false;
      cloudsEnabled = false;
    }
  })();

  // -------------------------
  // Init scene
  // -------------------------
  init();
  animate();

  function init(){
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x2b2b2f);
    scene.fog = new THREE.Fog(0x2b2b2f, 800, 4200);

    camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 6000);
    camera.position.set(0, 240, 480);
    camera.lookAt(0, 60, 0);

    renderer = new THREE.WebGLRenderer({ antialias: !performanceMode });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(performanceMode ? Math.min(window.devicePixelRatio || 1, 1) : Math.min(window.devicePixelRatio || 1.5, 2));
    document.body.appendChild(renderer.domElement);

    window.addEventListener('resize', onWindowResize);

    // lighting: stormy but not fully dark
    const hemi = new THREE.HemisphereLight(0x6b6d73, 0x222222, 0.7); scene.add(hemi);
    const sun = new THREE.DirectionalLight(0xddddff, 0.45); sun.position.set(-200,300,160); scene.add(sun);

    // ground darker green for storm feel
    const groundMat = new THREE.MeshPhongMaterial({ color: 0x334f33 });
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(3000,3000), groundMat);
    ground.rotation.x = -Math.PI/2;
    scene.add(ground);

    // overlay: ground scour
    createScourCanvas();

    // tornado visualization
    createTornadoVisual();

    // low wall cloud (kept small and low so it doesn't block view)
    createWallCloud();

    // debris group
    debrisGroup = new THREE.Group();
    scene.add(debrisGroup);

    // create storm clouds only if enabled and not in perf mode
    createStormCloudsIfAllowed();

    applyPerformanceMode();
    rebuildScene();
    updateWindRadius();
    paintScour();
  }

  function onWindowResize(){
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  }

  // -------------------------
  // Storm clouds (optional)
  // -------------------------
  function createStormCloudsIfAllowed(){
    if (!cloudsEnabled) return;
    // if performanceMode, avoid creating clouds
    if (performanceMode) return;
    if (stormClouds.length) return;
    const count = 22;
    for (let i=0;i<count;i++){
      const radius = 220 + Math.random()*700;
      const geo = new THREE.SphereGeometry(radius, 8, 6);
      geo.scale(1, 0.28, 1.6);
      const mat = new THREE.MeshLambertMaterial({ color:0x1f2024, transparent:true, opacity: 0.18, depthWrite:false });
      const m = new THREE.Mesh(geo, mat);
      // place well above camera but far out so not blocking view center
      m.position.set((Math.random()-0.5)*1600, 420 + Math.random()*240, (Math.random()-0.5)*1600);
      m.rotation.y = Math.random()*Math.PI*2;
      m.userData = { baseOpacity: 0.18 };
      scene.add(m);
      stormClouds.push(m);
    }
  }
  function removeStormClouds(){
    stormClouds.forEach(c => { scene.remove(c); });
    stormClouds = [];
  }

  // -------------------------
  // Wall cloud (low base)
  // -------------------------
  function createWallCloud(){
    if (wallCloud) scene.remove(wallCloud);
    wallCloud = new THREE.Group();
    const geo = new THREE.CylinderGeometry(120, 220, 40, 18, 1, true);
    geo.translate(0, 20, 0);
    const mat = new THREE.MeshLambertMaterial({ color: 0x1d1d20, transparent:true, opacity: 0.42, side: THREE.DoubleSide });
    const mesh = new THREE.Mesh(geo, mat);
    wallCloud.add(mesh);
    wallCloud.position.set(tornadoStart.x, 100, tornadoStart.z);
    scene.add(wallCloud);
  }

  // -------------------------
  // Tornado visual (rings + inner points)
  // -------------------------
  function createTornadoVisual(){
    if (tornado) scene.remove(tornado);
    tornado = new THREE.Group();
    const rings = performanceMode ? 20 : 36;
    for (let i=0;i<rings;i++){
      const R = Math.max(1, 38 - i * 1.05);
      const tube = 1.6;
      const geo = new THREE.TorusGeometry(R, tube, 8, 48);
      geo.rotateX(Math.PI/2);
      const y = (rings - i) * 5;
      geo.translate(0, y, 0);
      const mat = new THREE.MeshStandardMaterial({ color: 0x222225, transparent:true, opacity: 0.6 - (i/rings)*0.45, side: THREE.DoubleSide });
      const ring = new THREE.Mesh(geo, mat);
      ring.userData = { index: i };
      tornado.add(ring);
    }
    // inner particle cloud
    const pCount = performanceMode ? 400 : 1000;
    const pos = new Float32Array(pCount*3);
    for (let i=0;i<pCount;i++){
      pos[i*3+0] = (Math.random()-0.5)*20;
      pos[i*3+1] = Math.random()*220;
      pos[i*3+2] = (Math.random()-0.5)*20;
    }
    const g = new THREE.BufferGeometry();
    g.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    const pm = new THREE.PointsMaterial({ size: performanceMode ? 1.1 : 1.6, color:0xaaaaaa, transparent:true, opacity:0.9 });
    innerPoints = new THREE.Points(g, pm);
    tornado.add(innerPoints);

    tornado.position.set(tornadoStart.x, tornadoStart.y, tornadoStart.z);
    scene.add(tornado);
  }

  // -------------------------
  // Ground scour canvas overlay
  // -------------------------
  let scourCanvas, scourTexture, scourMesh;
  function createScourCanvas(){
    const SIZE = 2048;
    scourCanvas = document.createElement('canvas');
    scourCanvas.width = SIZE; scourCanvas.height = SIZE;
    scourTexture = new THREE.CanvasTexture(scourCanvas);
    scourTexture.wrapS = scourTexture.wrapT = THREE.ClampToEdgeWrapping;
    const mat = new THREE.MeshBasicMaterial({ map: scourTexture, transparent: true, opacity: 1, depthWrite:false });
    const plane = new THREE.PlaneGeometry(3000, 3000);
    scourMesh = new THREE.Mesh(plane, mat);
    scourMesh.rotation.x = -Math.PI/2;
    scourMesh.position.y = 0.02;
    scene.add(scourMesh);
    paintScour();
  }

  function paintScour(){
    if(!scourCanvas) return;
    const ctx = scourCanvas.getContext('2d');
    ctx.clearRect(0,0,scourCanvas.width, scourCanvas.height);
    const mapSize = 3000;
    const cx = (scourCanvas.width/2) + (tornado.position.x / mapSize) * scourCanvas.width;
    const cy = (scourCanvas.height/2) - (tornado.position.z / mapSize) * scourCanvas.height;
    const baseRadius = Math.max(120, (tornadoWindRadius / mapSize) * scourCanvas.width * (1 + windStrength / 140));
    const innerAlpha = Math.min(0.95, (windStrength / 220) * 1.6);
    const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, baseRadius);
    grad.addColorStop(0, `rgba(59,34,8,${innerAlpha})`);
    grad.addColorStop(0.35, `rgba(90,58,29,${innerAlpha*0.66})`);
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,scourCanvas.width, scourCanvas.height);
    scourTexture.needsUpdate = true;
  }

  // -------------------------
  // Scene population: houses, trees, debris
  // -------------------------
  function rebuildScene(){
    // remove old objects
    houses.forEach(h => scene.remove(h)); houses = [];
    trees.forEach(t => scene.remove(t)); trees = [];
    debris.forEach(d => debrisGroup.remove(d)); debris = [];

    const houseCount = performanceMode ? 8 : 18;
    const treeCount = performanceMode ? 24 : 70;
    const ambientDebris = performanceMode ? 60 : 240;

    // houses (bricks + roof tiles)
    for (let i=0;i<houseCount;i++){
      const house = new THREE.Group();
      const baseGroup = new THREE.Group();
      const W = 18, H = 10, D = 14;
      const brick = 3;
      const xs = Math.max(2, Math.floor(W/brick));
      const zs = Math.max(2, Math.floor(D/brick));
      for (let xi=0; xi<xs; xi++){
        for (let zi=0; zi<zs; zi++){
          const b = new THREE.Mesh(new THREE.BoxGeometry(brick, H-2, brick),
            new THREE.MeshStandardMaterial({ color: 0xb36a42 }));
          b.position.set((xi - (xs-1)/2) * brick, (H/2)-1, (zi - (zs-1)/2) * brick);
          baseGroup.add(b);
        }
      }
      house.add(baseGroup);
      const roof = new THREE.Group();
      const tx = 6, tz = 4;
      for (let txi=0; txi<tx; txi++){
        for (let tzi=0; tzi<tz; tzi++){
          const tile = new THREE.Mesh(new THREE.BoxGeometry(4,1.8,6),
            new THREE.MeshStandardMaterial({ color: 0x5e1515 }));
          tile.position.set((txi-(tx-1)/2)*4.2, H+1.6 + Math.random()*0.2, (tzi-(tz-1)/2)*6.2);
          roof.add(tile);
        }
      }
      house.add(roof);
      house.userData = { baseGroup, roofGroup: roof, damageAccum: 0 };
      house.position.set((Math.random()-0.5)*1400, 0, (Math.random()-0.5)*1400);
      scene.add(house); houses.push(house);
    }

    // trees (trunk + foliage layers)
    for (let i=0;i<treeCount;i++){
      const tree = new THREE.Group();
      const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.9,1.1,5,6),
        new THREE.MeshStandardMaterial({ color: 0x6b3f2a }));
      trunk.position.y = 2.5;
      tree.add(trunk);
      const foliage = new THREE.Group();
      const layers = performanceMode ? 2 : 4;
      for (let l=0;l<layers;l++){
        const cone = new THREE.Mesh(new THREE.ConeGeometry(3 + l*1.1, 6 + l*1.0, 8),
          new THREE.MeshStandardMaterial({ color: 0x1f7a1f }));
        cone.position.y = 6 + l*2.6;
        foliage.add(cone);
      }
      tree.add(foliage);
      tree.userData = { trunk, foliageGroup: foliage, damageAccum: 0 };
      tree.position.set((Math.random()-0.5)*1400, 0, (Math.random()-0.5)*1400);
      scene.add(tree); trees.push(tree);
    }

    // ambient debris
    for (let i=0;i<ambientDebris;i++){
      const s = 0.6 + Math.random()*2.4;
      const g = new THREE.BoxGeometry(s, Math.max(0.2,s*0.35), s*0.7);
      const m = new THREE.MeshStandardMaterial({ color: 0x7b7b7b });
      const p = new THREE.Mesh(g,m);
      p.position.set((Math.random()-0.5)*900, Math.random()*120 + 5, (Math.random()-0.5)*900);
      p.userData = { velocity: new THREE.Vector3(), life: undefined };
      debrisGroup.add(p); debris.push(p);
    }

    adjustTornadoScale();
    updateWindRadius();
    paintScour();
  }

  // -------------------------
  // Debris spawn helpers
  // -------------------------
  function spawnDebrisFromMesh(mesh, count = 3){
    const pos = new THREE.Vector3();
    mesh.getWorldPosition(pos);
    for (let i=0;i<count;i++){
      const s = 0.5 + Math.random()*2.2;
      const g = new THREE.BoxGeometry(s, Math.max(0.2,s*0.3), s*0.6);
      const m = mesh.material ? mesh.material.clone() : new THREE.MeshStandardMaterial({ color: 0x7b7b7b });
      const p = new THREE.Mesh(g,m);
      p.position.copy(pos).add(new THREE.Vector3((Math.random()-0.5)*6, 2 + Math.random()*3, (Math.random()-0.5)*6));
      p.userData = { velocity: new THREE.Vector3((Math.random()-0.5)*2, 2 + Math.random()*3, (Math.random()-0.5)*2), life: 8 + Math.random()*8 };
      debrisGroup.add(p); debris.push(p);
      if (debris.length > (performanceMode ? 800 : 2000)) break;
    }
  }
  function removeChildAndSpawn(parent, child){
    if(!parent || !child) return;
    parent.remove(child);
    spawnDebrisFromMesh(child, 3 + Math.floor(Math.random()*4));
  }

  // -------------------------
  // Damage & debris physics
  // -------------------------
  function applyDamageAndPhysics(delta){
    const center = new THREE.Vector3(tornado.position.x, 60, tornado.position.z);

    // Houses
    houses.forEach(h => {
      const dist = h.position.distanceTo(center);
      const prox = Math.max(0, 1 - dist / tornadoWindRadius);
      if (windStrength >= damageThreshold && prox > 0.02){
        const intensity = ((windStrength - damageThreshold) / (200 - damageThreshold + 0.0001)) * prox;
        h.userData.damageAccum = (h.userData.damageAccum || 0) + intensity * delta * (1 + Math.random()*0.8);
        if (h.userData.damageAccum > 0.5){
          const roof = h.userData.roofGroup;
          if (roof && roof.children.length > 0){
            const idx = Math.floor(Math.random() * roof.children.length);
            const tile = roof.children[idx];
            removeChildAndSpawn(roof, tile);
          } else {
            const base = h.userData.baseGroup;
            if (base && base.children.length > 0){
              const idx = Math.floor(Math.random() * base.children.length);
              const brick = base.children[idx];
              removeChildAndSpawn(base, brick);
            }
          }
          h.userData.damageAccum = Math.random()*0.25;
        }
      } else {
        h.userData.damageAccum = Math.max(0, (h.userData.damageAccum || 0) - delta * 0.15);
      }
    });

    // Trees
    trees.forEach(t => {
      const dist = t.position.distanceTo(center);
      const prox = Math.max(0, 1 - dist / (tornadoWindRadius * 0.95));
      if (windStrength >= damageThreshold && prox > 0.02){
        const intensity = ((windStrength - damageThreshold) / (200 - damageThreshold + 0.0001)) * prox;
        t.userData.damageAccum = (t.userData.damageAccum || 0) + intensity * delta * (1 + Math.random()*0.6);
        if (t.userData.damageAccum > 0.45){
          const fol = t.userData.foliageGroup;
          if (fol && fol.children.length > 0){
            const idx = Math.floor(Math.random() * fol.children.length);
            const piece = fol.children[idx];
            removeChildAndSpawn(fol, piece);
          } else {
            const trunk = t.userData.trunk;
            if (trunk && trunk.parent) removeChildAndSpawn(t, trunk);
          }
          t.userData.damageAccum = Math.random()*0.2;
        }
      } else {
        t.userData.damageAccum = Math.max(0, (t.userData.damageAccum || 0) - delta * 0.14);
      }
    });

    // Debris physics (swirl + pull + updraft)
    const tNow = performance.now() * 0.001;
    const maxPull = tornadoWindRadius * 1.6;
    for (let i = debris.length - 1; i >= 0; i--){
      const p = debris[i];
      if (p.userData.life !== undefined){
        p.userData.life -= delta;
        if (p.userData.life <= 0){ debrisGroup.remove(p); debris.splice(i,1); continue; }
      }
      const dir = new THREE.Vector3().subVectors(center, p.position);
      const dist = dir.length();
      if (dist > maxPull){
        p.userData.velocity.y -= 9.8 * 0.018 * delta;
        p.userData.velocity.multiplyScalar(0.995);
        p.position.addScaledVector(p.userData.velocity, delta * 60);
        continue;
      }
      const radial = dir.clone().normalize();
      const tangential = new THREE.Vector3(-radial.z, 0, radial.x);
      const proximity = Math.max(0, 1 - dist / maxPull);
      const pull = 0.8 * (windStrength / 140) * proximity;
      const swirl = 0.45 * (1 + proximity * 1.8) * (windStrength / 160);
      const up = 0.6 * (1 + proximity) * (windStrength / 200);
      const wobble = Math.sin(tNow * 6 + i) * 0.02;
      p.userData.velocity.addScaledVector(radial, pull * delta * 200);
      p.userData.velocity.addScaledVector(tangential, swirl * delta * 200);
      p.userData.velocity.y += (up + wobble) * delta * 60;
      p.userData.velocity.multiplyScalar(0.993);
      p.position.addScaledVector(p.userData.velocity, delta * 60);
      if (dist < 8){
        if (Math.random() < 0.25) p.userData.life = 3 + Math.random()*4;
        else { debrisGroup.remove(p); debris.splice(i,1); }
      }
    }
  }

  // -------------------------
  // Lightning from wall cloud region
  // -------------------------
  function maybeLightning(delta){
    lightningTimer -= delta;
    if (lightningTimer <= 0){
      lightningTimer = 0.6 + Math.random()*3.2;
      if (Math.random() < 0.45) doLightning();
    }
  }
  function doLightning(){
    const origin = new THREE.Vector3(
      tornado.position.x + (Math.random()-0.5)*160,
      tornado.position.y + 80 + Math.random()*80,
      tornado.position.z + (Math.random()-0.5)*160
    );
    const target = new THREE.Vector3(
      tornado.position.x + (Math.random()-0.5)*600,
      0,
      tornado.position.z + (Math.random()-0.5)*600
    );
    const seg = 8; const pts = [];
    for (let i=0;i<=seg;i++){
      const t = i/seg;
      const y = origin.y * (1 - t);
      const x = origin.x + (target.x - origin.x) * t + (Math.random()-0.5)*40*(1-t);
      const z = origin.z + (target.z - origin.z) * t + (Math.random()-0.5)*40*(1-t);
      pts.push(new THREE.Vector3(x,y,z));
    }
    const geo = new THREE.BufferGeometry().setFromPoints(pts);
    const mat = new THREE.LineBasicMaterial({ color:0xffffff, linewidth:2 });
    const bolt = new THREE.Line(geo, mat);
    scene.add(bolt);
    const flash = new THREE.PointLight(0xffffff, 2.6, 1200);
    flash.position.copy(target).add(new THREE.Vector3(0,40,0));
    scene.add(flash);
    setTimeout(()=>{ scene.remove(bolt); scene.remove(flash); }, 90 + Math.random()*150);
  }

  // -------------------------
  // Funnel drop & start
  // -------------------------
  function startDrop(){
    if (dropping || animating) return;
    dropping = true; animating = false;
    tornado.position.set(tornadoStart.x, tornadoStart.y, tornadoStart.z);
    const duration = 1100;
    const fromY = tornadoStart.y, toY = 60;
    const start = performance.now();
    (function step(now){
      const t = Math.min(1, (now - start) / duration);
      const e = 1 - Math.pow(1 - t, 3); // ease
      tornado.position.y = fromY * (1 - e) + toY * e;
      tornado.children.forEach((r, idx) => r.rotation.y += 0.03 + idx*0.001);
      if (t < 1) requestAnimationFrame(step);
      else { dropping = false; animating = true; }
    })(performance.now());
  }

  // -------------------------
  // Reset (should return tornado to start and clear debris/houses etc.)
  // -------------------------
  function resetAll(){
    animating = false; dropping = false;
    tornado.position.set(tornadoStart.x, tornadoStart.y, tornadoStart.z);
    tornado.rotation.set(0,0,0);
    // remove existing objects and debris
    houses.forEach(h => scene.remove(h)); houses = [];
    trees.forEach(t => scene.remove(t)); trees = [];
    debris.forEach(d => debrisGroup.remove(d)); debris = [];
    // clear scour canvas
    if (scourCanvas){
      const ctx = scourCanvas.getContext('2d'); ctx.clearRect(0,0,scourCanvas.width, scourCanvas.height);
      scourTexture.needsUpdate = true;
    }
    rebuildScene();
  }

  // -------------------------
  // Utility functions
  // -------------------------
  function mphToUnitsPerSec(mph){ return mph * 0.02; }
  function updateWindRadius(){ tornadoWindRadius = Math.max(80, tornadoWidth * 2.2 * (1 + windStrength / 140)); }
  function adjustTornadoScale(){
    const s = Math.max(0.5, Math.min(3.2, tornadoWidth / 50));
    tornado.scale.set(s,1,s);
    if (innerPoints){
      const positions = innerPoints.geometry.attributes.position.array;
      for (let i=0;i<positions.length/3;i++){
        positions[i*3+0] = (Math.random()-0.5) * 26 * s;
        positions[i*3+1] = Math.random() * 220;
        positions[i*3+2] = (Math.random()-0.5) * 26 * s;
      }
      innerPoints.geometry.attributes.position.needsUpdate = true;
    }
  }
  function applyPerformanceMode(){
    perfState.textContent = performanceMode ? 'ON' : 'OFF';
    if (renderer) renderer.setPixelRatio(performanceMode ? Math.min(window.devicePixelRatio || 1, 1) : Math.min(window.devicePixelRatio || 1.5, 2));
    // re-create tornado with detail adjusted
    if (tornado) {
      scene.remove(tornado);
      createTornadoVisual();
      scene.add(tornado);
    }
    // hide clouds automatically on perf
    if (performanceMode && stormClouds.length) removeStormClouds();
  }

  // -------------------------
  // Main animation loop
  // -------------------------
  function animate(){
    requestAnimationFrame(animate);
    const now = performance.now();
    const delta = Math.min(0.05, (now - lastTime) / 1000);
    lastTime = now;

    // tornado forward movement uses tornadoSpeedMph (not windStrength)
    if (animating && !dropping){
      const unitsPerSec = mphToUnitsPerSec(tornadoSpeedMph);
      tornado.position.x += unitsPerSec * delta * 60;
    }

    // rotate rings (visual)
    const ringSpeed = 0.04 + (windStrength / 240) * 0.5;
    tornado.children.forEach((r, idx) => r.rotation.y += ringSpeed * (1 + idx*0.002));
    if (innerPoints) innerPoints.rotation.y += 0.05 + (windStrength / 500);

    // wall cloud follows tornado
    if (wallCloud) wallCloud.position.lerp(new THREE.Vector3(tornado.position.x, 90, tornado.position.z), 0.06);

    // small cloud rotation/opacity tweak (if created)
    stormClouds.forEach(c => {
      c.rotation.y += 0.0008 * (1 + windStrength/200);
      // fade by distance
      const d = camera.position.distanceTo(c.position);
      const fade = Math.max(0.12, 1 - (d / 4200));
      c.material.opacity = (c.userData.baseOpacity || c.material.opacity) * fade;
    });

    // update scour canvas
    paintScour();

    // physics & damage
    if (animating){
      applyDamageAndPhysics(delta);
    } else {
      // gentle debris settle
      for (let i=debris.length-1;i>=0;i--){
        const p = debris[i];
        p.userData.velocity.y -= 9.8 * 0.018 * delta;
        p.userData.velocity.multiplyScalar(0.995);
        p.position.addScaledVector(p.userData.velocity, delta * 60);
        if (p.userData.life !== undefined){
          p.userData.life -= delta;
          if (p.userData.life <= 0){ debrisGroup.remove(p); debris.splice(i,1); }
        }
      }
    }

    // lightning
    maybeLightning(delta);

    // camera follow (gentle smoothing)
    camera.position.x += (tornado.position.x + 120 - camera.position.x) * 0.03;
    camera.position.z += (tornado.position.z + 360 - camera.position.z) * 0.03;
    camera.lookAt(new THREE.Vector3(tornado.position.x, 60, tornado.position.z));

    renderer.render(scene, camera);
  }

  // -------------------------
  // Expose a couple helpers to console for debugging (optional)
  // -------------------------
  window._sim = {
    scene, camera, renderer, tornado,
    rebuildScene: () => rebuildScene(),
    removeStormClouds,
    createStormCloudsIfAllowed
  };

  // initial setup done above
});
</script>
</body>
</html>
