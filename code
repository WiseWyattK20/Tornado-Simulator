<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tornado Simulator (No Clouds)</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; background: #222; }
    #controls {
      position: absolute; top: 10px; left: 10px; background: rgba(255,255,255,0.9);
      padding: 10px; border-radius: 8px; z-index: 10; max-width: 200px;
    }
    #controls input { width: 150px; }
    button { margin: 5px 0; padding: 5px 10px; }
  </style>
</head>
<body>
  <div id="controls">
    <label>Wind Speed (mph): <span id="windValue">100</span></label><br />
    <input type="range" id="windSlider" min="10" max="331" value="100" /><br />
    <label>Tornado Speed (mph): <span id="speedValue">10</span></label><br />
    <input type="range" id="speedSlider" min="0" max="90" value="10" /><br />
    <label>Tornado Width: <span id="widthValue">80</span></label><br />
    <input type="range" id="widthSlider" min="20" max="250" value="80" /><br />
    <button id="startBtn">Start</button>
    <button id="resetBtn">Reset</button><br/>
    <label><input type="checkbox" id="perfToggle" checked /> Performance Mode</label>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script>
  let scene, camera, renderer;
  let tornado, debrisGroup, structures = [], debrisParticles = [];
  let tornadoSpeed = 0.05, animating = false;
  let funnelHeight = 160, funnelTop = 40, funnelBottom = 5;
  let ground, scourCtx, scourTexture;

  // UI elements
  const windSlider = document.getElementById("windSlider");
  const speedSlider = document.getElementById("speedSlider");
  const widthSlider = document.getElementById("widthSlider");
  const windValue = document.getElementById("windValue");
  const speedValue = document.getElementById("speedValue");
  const widthValue = document.getElementById("widthValue");
  const perfToggle = document.getElementById("perfToggle");

  windSlider.oninput = () => windValue.textContent = windSlider.value;
  speedSlider.oninput = () => speedValue.textContent = speedSlider.value;
  widthSlider.oninput = () => {
    widthValue.textContent = widthSlider.value;
    let scale = widthSlider.value / 80;
    tornado.scale.set(scale, 1, scale);
  };

  init();
  animate();

  function init() {
    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 5000);
    camera.position.set(0, 200, 500);
    camera.lookAt(0,0,0);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lights
    scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(-100,200,100);
    scene.add(dirLight);

    // Ground with scour effect
    let canvas = document.createElement("canvas");
    canvas.width = canvas.height = 1024;
    scourCtx = canvas.getContext("2d");
    scourCtx.fillStyle = "#3a7a3a";
    scourCtx.fillRect(0,0,1024,1024);
    scourTexture = new THREE.CanvasTexture(canvas);

    ground = new THREE.Mesh(
      new THREE.PlaneGeometry(2000,2000),
      new THREE.MeshPhongMaterial({ map: scourTexture })
    );
    ground.rotation.x = -Math.PI/2;
    scene.add(ground);

    // Tornado funnel
    let funnelGeo = new THREE.CylinderGeometry(funnelBottom,funnelTop,funnelHeight,16,1,true);
    let funnelMat = new THREE.MeshStandardMaterial({ color: 0x666666, transparent:true, opacity:0.7, side:THREE.DoubleSide });
    tornado = new THREE.Mesh(funnelGeo, funnelMat);
    tornado.position.set(-600,funnelHeight/2,0);
    scene.add(tornado);

    // Structures
    for (let i=0;i<20;i++){
      let house = new THREE.Mesh(
        new THREE.BoxGeometry(30,20,30),
        new THREE.MeshStandardMaterial({ color: 0xa0522d })
      );
      house.position.set((Math.random()-0.5)*1500,10,(Math.random()-0.5)*1500);
      house.userData = { damaged:0 };
      scene.add(house);
      structures.push(house);
    }
    for (let i=0;i<15;i++){
      let tree = new THREE.Mesh(
        new THREE.CylinderGeometry(1,1,15,6),
        new THREE.MeshStandardMaterial({ color:0x8b4513 })
      );
      let leaves = new THREE.Mesh(
        new THREE.SphereGeometry(8,8,8),
        new THREE.MeshStandardMaterial({ color:0x228B22 })
      );
      tree.add(leaves);
      leaves.position.y = 10;
      tree.position.set((Math.random()-0.5)*1500,7,(Math.random()-0.5)*1500);
      tree.userData = { damaged:0 };
      scene.add(tree);
      structures.push(tree);
    }

    // Debris
    debrisGroup = new THREE.Group();
    scene.add(debrisGroup);
    for (let i=0;i<100;i++){
      let d = new THREE.Mesh(
        new THREE.BoxGeometry(1,1,1),
        new THREE.MeshStandardMaterial({ color:0x888888 })
      );
      d.position.set((Math.random()-0.5)*800,Math.random()*100,(Math.random()-0.5)*800);
      d.userData.velocity=new THREE.Vector3();
      debrisGroup.add(d);
      debrisParticles.push(d);
    }

    // Buttons
    document.getElementById("startBtn").onclick=()=>{
      animating=true; resetStructures(); resetDebris();
      tornado.position.set(-600,funnelHeight/2,0);
    };
    document.getElementById("resetBtn").onclick=()=>{
      animating=false; resetStructures(); resetDebris();
      tornado.position.set(-600,funnelHeight/2,0);
    };

    window.addEventListener("resize",()=>{
      camera.aspect=window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth,window.innerHeight);
    });
  }

  function resetStructures(){
    structures.forEach(s=>{
      s.userData.damaged=0;
      if(s.geometry.type==="BoxGeometry"){ s.material.color.set(0xa0522d); }
      else{ s.children[0].material.color.set(0x228B22); }
      s.visible=true;
    });
    scourCtx.fillStyle = "#3a7a3a";
    scourCtx.fillRect(0,0,1024,1024);
    scourTexture.needsUpdate = true;
  }

  function resetDebris(){
    debrisParticles.forEach(d=>{
      d.position.set((Math.random()-0.5)*800,Math.random()*100,(Math.random()-0.5)*800);
      d.userData.velocity.set(0,0,0);
    });
  }

  function damageStructure(s, wind){
    if(s.userData.damaged>=3) return;
    if(Math.random()<wind/500){ // higher wind, more likely
      s.userData.damaged++;
      if(s.geometry.type==="BoxGeometry"){
        if(s.userData.damaged===1) s.material.color.set(0x8b4513);
        if(s.userData.damaged===2) s.material.color.set(0x555555);
        if(s.userData.damaged===3) s.visible=false;
      } else {
        if(s.userData.damaged===1) s.children[0].material.color.set(0x006400);
        if(s.userData.damaged===2) s.children[0].material.color.set(0x444444);
        if(s.userData.damaged===3) s.visible=false;
      }
    }
  }

  function addScour(x,z,strength){
    let ctxX = Math.floor((x/2000+0.5)*1024);
    let ctxY = Math.floor((z/2000+0.5)*1024);
    let rad = 20 + strength/2;
    let grad = scourCtx.createRadialGradient(ctxX,ctxY,0,ctxX,ctxY,rad);
    grad.addColorStop(0, `rgb(${100-strength},${60-strength/2},0)`);
    grad.addColorStop(1,"rgba(0,0,0,0)");
    scourCtx.fillStyle = grad;
    scourCtx.beginPath();
    scourCtx.arc(ctxX,ctxY,rad,0,Math.PI*2);
    scourCtx.fill();
    scourTexture.needsUpdate=true;
  }

  function animate(){
    requestAnimationFrame(animate);
    if(animating){
      let move = parseFloat(speedSlider.value)/50*tornadoSpeed;
      tornado.position.x += move;
      tornado.rotation.y += 0.05;

      let wind = parseFloat(windSlider.value);

      // Damage + scour
      structures.forEach(s=>{
        let dist = s.position.distanceTo(tornado.position);
        if(dist < parseFloat(widthSlider.value)){
          damageStructure(s, wind);
        }
      });
      addScour(tornado.position.x, tornado.position.z, wind/10);

      // Debris
      debrisParticles.forEach(d=>{
        let dir = new THREE.Vector3().subVectors(tornado.position,d.position);
        let dist = dir.length();
        if(dist<parseFloat(widthSlider.value)){
          dir.normalize();
          d.userData.velocity.add(dir.multiplyScalar(0.2));
          d.userData.velocity.y += 0.05;
          d.position.add(d.userData.velocity);
        }
      });
    }
    renderer.render(scene,camera);
  }
  </script>
</body>
</html>
