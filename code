<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tornado Simulator — Fixed & Procedural Damage</title>
<style>
  html,body { height:100%; margin:0; }
  body { font-family: Arial, sans-serif; overflow:hidden; }
  #controls {
    position: absolute; left: 10px; top: 10px; z-index: 30;
    background: rgba(255,255,255,0.92); padding:10px; border-radius:8px;
    width: 260px; box-shadow:0 6px 18px rgba(0,0,0,0.15);
  }
  #controls input[type=range] { width: 180px; }
  #controls label { font-size:13px; }
  button { margin-top:6px; padding:6px 10px; }
  #status { position: absolute; right: 12px; top: 12px; z-index: 30; color:#111; background: rgba(255,255,255,0.85); padding:6px 8px; border-radius:6px; font-size:13px; }
</style>
</head>
<body>
<div id="controls">
  <label>Wind Speed (mph): <strong id="windValue">50</strong></label><br>
  <input id="windSlider" type="range" min="10" max="200" value="50"><br>

  <label>Tornado Speed (mph): <strong id="speedValue">20</strong></label><br>
  <input id="speedSlider" type="range" min="1" max="90" value="20"><br>

  <label>Tornado Width: <strong id="widthValue">50</strong></label><br>
  <input id="widthSlider" type="range" min="10" max="250" value="50"><br>

  <label>Performance Mode (auto):</label>
  <input id="perfToggle" type="checkbox" checked><br>

  <button id="startBtn">Start</button>
  <button id="resetBtn">Reset</button>
</div>

<div id="status">Perf: <span id="perfState">AUTO</span></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script>
/* -------------------------------------------------------
  Tornado Simulator — bugfixed & procedural destruction
  - Reset returns tornado to its start pos
  - Supercell & wall cloud now present and follow tornado
  - Lightning bolts originate from wall cloud -> ground
  - Procedural continuous damage while wind >= damageThreshold
  - Debris spawns from destroyed parts and is sucked into vortex
  - Performance mode auto-detected and toggleable
-------------------------------------------------------*/

let scene, camera, renderer;
let tornado, tornadoStart = new THREE.Vector3(-400, 60, 0);
let debrisGroup, debrisParticles = [];
let houses = [], trees = [];
let supercell, wallCloud;
let animating = false;

let windSpeed = 50;       // mph (UI)
let tornadoSpeedMph = 20; // mph (UI)
let tornadoWidth = 50;    // UI slider -> affects wind radius
let tornadoWindRadius = tornadoWidth * 2;
let performanceMode = true;
let damageThreshold = 75; // damage occurs only while windSpeed >= damageThreshold
let lastTime = performance.now();
let lightningTimer = 0;

// UI
const windSlider = document.getElementById('windSlider');
const speedSlider = document.getElementById('speedSlider');
const widthSlider = document.getElementById('widthSlider');
const windValue = document.getElementById('windValue');
const speedValue = document.getElementById('speedValue');
const widthValue = document.getElementById('widthValue');
const perfToggle = document.getElementById('perfToggle');
const perfState = document.getElementById('perfState');

windSlider.oninput = () => { windSpeed = Number(windSlider.value); windValue.textContent = windSlider.value; };
speedSlider.oninput = () => { tornadoSpeedMph = Number(speedSlider.value); speedValue.textContent = speedSlider.value; };
widthSlider.oninput = () => { tornadoWidth = Number(widthSlider.value); widthValue.textContent = widthSlider.value; updateWindRadius(); };
perfToggle.onchange = () => { performanceMode = perfToggle.checked; applyPerformanceMode(); setupSceneObjects(); };

document.getElementById('startBtn').onclick = ()=> animating = true;
document.getElementById('resetBtn').onclick = ()=> resetAll();

function detectAutoPerf(){
  // Auto-enable performance mode for low-memory / mobile devices
  let mem = navigator.deviceMemory || 4;
  let ua = navigator.userAgent || '';
  let isMobile = /Mobi|Android|iPhone|iPad|iPod|Windows Phone/i.test(ua);
  if(mem <= 2 || isMobile) performanceMode = true; else performanceMode = false;
  perfToggle.checked = performanceMode;
  perfState.textContent = performanceMode ? 'ON' : 'OFF';
}
detectAutoPerf();

function applyPerformanceMode(){
  perfState.textContent = performanceMode ? 'ON' : 'OFF';
  // renderer antialiasing controlled at init only; recreating renderer on toggle is heavier.
  // We'll just adjust pixel ratio and counts via setupSceneObjects()
  if(renderer) renderer.setPixelRatio(performanceMode ? Math.min(window.devicePixelRatio||1,1) : Math.min(window.devicePixelRatio||1.5,2));
}

// ---- init ----
init();
animate();

function init(){
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);

  camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 5000);
  camera.position.set(0,220,520);
  camera.lookAt(0,60,0);

  renderer = new THREE.WebGLRenderer({ antialias: !performanceMode });
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(performanceMode ? Math.min(window.devicePixelRatio||1,1) : Math.min(window.devicePixelRatio||1.5,2));
  document.body.appendChild(renderer.domElement);

  window.addEventListener('resize', ()=> {
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  // lighting
  const hemi = new THREE.HemisphereLight(0xe8f5ff, 0x444444, 0.95);
  scene.add(hemi);
  const sun = new THREE.DirectionalLight(0xffffff, 0.8);
  sun.position.set(-200,300,120);
  scene.add(sun);

  // ground
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(3000,3000), new THREE.MeshPhongMaterial({color:0x7dbb6b}));
  ground.rotation.x = -Math.PI/2;
  scene.add(ground);

  // tornado (visual). Keep visual scale limited; physics use tornadoWindRadius.
  const funnelGeo = new THREE.CylinderGeometry(22,6,220,24,1,true);
  funnelGeo.translate(0,110,0); // lift so base rests on y=0
  const funnelMat = new THREE.MeshStandardMaterial({ color:0x333333, transparent:true, opacity:0.72, side: THREE.DoubleSide });
  tornado = new THREE.Mesh(funnelGeo, funnelMat);
  tornado.position.copy(tornadoStart);
  scene.add(tornado);

  // add a subtle inner swirl for visuals
  const inner = new THREE.Mesh(new THREE.CylinderGeometry(8,30,200,12,1,true),
                               new THREE.MeshStandardMaterial({color:0x222222, transparent:true, opacity:0.9}));
  inner.geometry.translate(0,100,0);
  tornado.add(inner);

  // debris group
  debrisGroup = new THREE.Group();
  scene.add(debrisGroup);

  // supercell & wall cloud
  supercell = new THREE.Group();
  wallCloud = new THREE.Group();
  // create visible cloud geometry (flattened spheroids) but start them at tornado location so they are not floating at 0,0
  for(let i=0;i<10;i++){
    const g = new THREE.SphereGeometry(70 + Math.random()*80, 8, 6);
    g.scale(1, 0.5, 1.6);
    const m = new THREE.Mesh(g, new THREE.MeshLambertMaterial({color:0x44464e, transparent:true, opacity:0.35}));
    m.position.set((Math.random()-0.5)*200, 0, (Math.random()-0.5)*200);
    supercell.add(m);
  }
  const w = new THREE.CylinderGeometry(140,220,50,18);
  const wm = new THREE.Mesh(w, new THREE.MeshLambertMaterial({color:0x222229, transparent:true, opacity:0.4}));
  wm.geometry.translate(0,25,0);
  wallCloud.add(wm);

  scene.add(supercell);
  scene.add(wallCloud);

  // initial objects
  applyPerformanceMode();
  setupSceneObjects();
  updateWindRadius();
}

// ---- scene objects creation ----
function setupSceneObjects(){
  // clear previous
  houses.forEach(h => scene.remove(h)); houses.length = 0;
  trees.forEach(t => scene.remove(t)); trees.length = 0;
  debrisParticles.forEach(d => debrisGroup.remove(d)); debrisParticles.length = 0;

  // counts scaled for perf
  const houseCount = performanceMode ? 10 : 24;
  const treeCount  = performanceMode ? 28 : 80;
  const debrisCount = performanceMode ? 70 : 240;

  // Houses: create with several removable roof-chunks to allow randomized partial destruction
  for(let i=0;i<houseCount;i++){
    const house = new THREE.Group();
    const base = new THREE.Mesh(new THREE.BoxGeometry(22,12,18), new THREE.MeshStandardMaterial({color:0xa0522d}));
    base.position.y = 6;
    house.add(base);

    // roof split into tiles/sections for procedural removal
    const roofGroup = new THREE.Group();
    const tilesX = 3, tilesZ = 3;
    const tileW = 10, tileH = 4, tileD = 6;
    for(let xi=0; xi<tilesX; xi++){
      for(let zi=0; zi<tilesZ; zi++){
        const tile = new THREE.Mesh(new THREE.BoxGeometry(tileW, tileH, tileD), new THREE.MeshStandardMaterial({color:0x6b0b0b}));
        tile.position.set((xi - (tilesX-1)/2) * tileW * 0.9, 12 + Math.random()*0.4, (zi - (tilesZ-1)/2) * tileD * 0.9);
        tile.userData.isRoofTile = true;
        roofGroup.add(tile);
      }
    }
    house.add(roofGroup);

    // position the house in the world
    house.position.set((Math.random()-0.5)*1400, 0, (Math.random()-0.5)*1400);

    // store original state for reset
    house.userData.original = {
      position: house.position.clone(),
      rotation: house.rotation.clone(),
      roofCount: roofGroup.children.length
    };
    // damage tracking
    house.userData.parts = { base, roofGroup };
    house.userData.removedParts = [];
    house.userData.damageAccum = 0;

    scene.add(house);
    houses.push(house);
  }

  // Trees: multiple foliage chunks so they can be removed piece-by-piece
  for(let i=0;i<treeCount;i++){
    const tree = new THREE.Group();
    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.9,1.1,6,6), new THREE.MeshStandardMaterial({color:0x6b3f2a}));
    trunk.position.y = 3;
    tree.add(trunk);

    const foliageGroup = new THREE.Group();
    const layers = performanceMode ? 2 : 4;
    for(let l=0;l<layers;l++){
      const foliage = new THREE.Mesh(new THREE.ConeGeometry(3 + l*1.3, 6 + l*1.2, 8), new THREE.MeshStandardMaterial({color:0x1f7a1f}));
      foliage.position.y = 6 + l*3;
      foliage.userData.isFoliage = true;
      foliageGroup.add(foliage);
    }
    tree.add(foliageGroup);

    tree.position.set((Math.random()-0.5)*1400, 0, (Math.random()-0.5)*1400);
    tree.userData.original = { position: tree.position.clone(), foliageCount: foliageGroup.children.length };
    tree.userData.parts = { trunk, foliageGroup };
    tree.userData.removedParts = [];
    tree.userData.damageAccum = 0;

    scene.add(tree);
    trees.push(tree);
  }

  // initial ambient debris (loose objects)
  for(let i=0;i<debrisCount;i++){
    const size = 0.6 + Math.random()*2.2;
    const geo = new THREE.BoxGeometry(size, Math.max(0.2,size*0.4), size*0.7);
    const mat = new THREE.MeshStandardMaterial({ color: 0x7b7b7b });
    const d = new THREE.Mesh(geo, mat);
    d.position.set((Math.random()-0.5)*900, Math.random()*140 + 5, (Math.random()-0.5)*900);
    d.userData.velocity = new THREE.Vector3();
    debrisGroup.add(d);
    debrisParticles.push(d);
  }

  // ensure tornado visuals scale boundedly
  const visualScale = Math.max(0.5, Math.min(2.5, tornadoWidth / 50));
  tornado.scale.set(visualScale, 1, visualScale);

  // place supercell/wallCloud at tornado start so they aren't at origin visible unexpectedly
  supercell.position.set(tornado.position.x, 120, tornado.position.z);
  wallCloud.position.set(tornado.position.x, 90, tornado.position.z);
}

// ---- helpers ----
function updateWindRadius(){
  tornadoWindRadius = Math.max(60, tornadoWidth * 2); // minimum field
  // but don't visually explode funnel: cap visual scale
  const visualScale = Math.max(0.5, Math.min(2.5, tornadoWidth / 50));
  tornado.scale.set(visualScale, 1, visualScale);
}

function spawnDebrisAt(worldPos, color=null, count=3){
  // spawn a few debris pieces at worldPos
  for(let i=0;i<count;i++){
    // size random
    const sx = 0.6 + Math.random()*2.6;
    const geo = new THREE.BoxGeometry(sx, Math.max(0.2,sx*0.35), sx*0.6);
    const mat = new THREE.MeshStandardMaterial({ color: color ? color.clone() : 0x7b7b7b });
    const m = new THREE.Mesh(geo, mat);
    m.position.copy(worldPos).add(new THREE.Vector3((Math.random()-0.5)*6, 2 + Math.random()*3, (Math.random()-0.5)*6));
    m.userData.velocity = new THREE.Vector3((Math.random()-0.5)*2, 2 + Math.random()*3, (Math.random()-0.5)*2);
    m.userData.life = 12 + Math.random()*10; // limit lifetime
    debrisGroup.add(m);
    debrisParticles.push(m);
    // cap total debris to avoid explosion
    if(debrisParticles.length > (performanceMode ? 400 : 900)) break;
  }
}

// convert local child position to world and remove it from parent and spawn debris
function removePartAndSpawn(partMesh){
  const posWorld = new THREE.Vector3();
  partMesh.getWorldPosition(posWorld);
  // remove from parent (safe)
  const parent = partMesh.parent;
  if(parent) parent.remove(partMesh);
  spawnDebrisAt(posWorld, partMesh.material && partMesh.material.color ? partMesh.material.color : null, 3);
}

// ---- damage & physics ----
function applyDamageAndPhysics(delta){
  // tornado center for fly-in forces (use lower mid point)
  const tornadoCenter = new THREE.Vector3(tornado.position.x, 60, tornado.position.z);

  // houses
  houses.forEach(h => {
    const parts = h.userData.parts;
    const pos = h.position;
    const dist = pos.distanceTo(tornadoCenter);
    const proximity = Math.max(0, 1 - dist / tornadoWindRadius);

    // damage only if wind is strong enough
    if(windSpeed >= damageThreshold && proximity > 0.02){
      // damage intensity scales with windSpeed over threshold and proximity
      const intensity = ((windSpeed - damageThreshold) / (200 - damageThreshold)) * proximity;
      h.userData.damageAccum += intensity * delta * 1.0; // accumulate over time

      // when enough accumulated, remove a random roof tile (if any left) or base last
      if(h.userData.damageAccum > 0.5){
        const roofGroup = parts.roofGroup;
        if(roofGroup && roofGroup.children.length > 0){
          // pick random tile
          const idx = Math.floor(Math.random() * roofGroup.children.length);
          const tile = roofGroup.children[idx];
          removePartAndSpawn(tile);
          h.userData.removedParts.push(tile);
        } else if(parts.base && parts.base.visible){
          // remove base (big collapse)
          const base = parts.base;
          // spawn a few larger debris
          removePartAndSpawn(base);
        }
        // reset accumulation with some randomness to make destruction varied in time
        h.userData.damageAccum = Math.random() * 0.2;
      }
    } else {
      // recover accumulation slowly when winds drop below threshold (prevents instant repeat)
      h.userData.damageAccum = Math.max(0, h.userData.damageAccum - delta * 0.25);
    }
  });

  // trees
  trees.forEach(t => {
    const pos = t.position;
    const dist = pos.distanceTo(tornadoCenter);
    const proximity = Math.max(0, 1 - dist / (tornadoWindRadius * 0.9));
    if(windSpeed >= damageThreshold && proximity > 0.02){
      const intensity = ((windSpeed - damageThreshold) / (200 - damageThreshold)) * proximity;
      t.userData.damageAccum += intensity * delta * 1.2;
      if(t.userData.damageAccum > 0.4){
        // remove a random foliage piece if any left
        const foliageGroup = t.userData.parts.foliageGroup;
        if(foliageGroup && foliageGroup.children.length > 0){
          const idx = Math.floor(Math.random()*foliageGroup.children.length);
          const piece = foliageGroup.children[idx];
          removePartAndSpawn(piece);
          t.userData.removedParts.push(piece);
        } else {
          // if no foliage left, remove trunk (collapse)
          const trunk = t.userData.parts.trunk;
          if(trunk && trunk.visible){
            removePartAndSpawn(trunk);
          }
        }
        t.userData.damageAccum = Math.random() * 0.2;
      }
    } else {
      t.userData.damageAccum = Math.max(0, t.userData.damageAccum - delta * 0.2);
    }
  });

  // debris physics — swirl + suction + updraft
  const time = performance.now() * 0.001;
  const maxPullRadius = tornadoWindRadius * 1.6;
  for(let i = debrisParticles.length - 1; i >= 0; i--){
    const d = debrisParticles[i];
    // lifetime removal if set
    if(d.userData.life !== undefined){
      d.userData.life -= delta;
      if(d.userData.life <= 0){
        debrisGroup.remove(d);
        debrisParticles.splice(i, 1);
        continue;
      }
    }

    const dir = new THREE.Vector3().subVectors(tornadoCenter, d.position);
    const dist = dir.length();
    // if too far, apply small ambient drift
    if(dist > maxPullRadius){
      // slight gravity + settling
      d.userData.velocity.y -= 9.8 * 0.02 * delta;
      d.userData.velocity.multiplyScalar(0.995); // damping
      d.position.addScaledVector(d.userData.velocity, delta * 60);
      continue;
    }

    // within influence -> swirl + pull
    // radial normalized (towards center)
    const radial = dir.clone().normalize();
    // tangential (perpendicular on XZ plane)
    const tangential = new THREE.Vector3(-radial.z, 0, radial.x);
    const proximity = Math.max(0, 1 - dist / maxPullRadius);

    // Strength scales with windSpeed and proximity
    const pull = 0.6 * (windSpeed / 120) * proximity; // how fast it pulls inward
    const swirl = 0.35 * (1 + proximity * 2) * (windSpeed / 140); // tangential swirl
    const updraft = 0.6 * (1 + proximity) * (windSpeed / 160);

    // small time-varying wobble
    const wobble = Math.sin(time * 6 + i) * 0.02;

    // update velocity
    d.userData.velocity.addScaledVector(radial, pull * delta * 200);       // pull inward
    d.userData.velocity.addScaledVector(tangential, swirl * delta * 200);   // swirl
    d.userData.velocity.y += (updraft + wobble) * delta * 60;              // upward lift
    // damping
    d.userData.velocity.multiplyScalar(0.995);

    // move
    d.position.addScaledVector(d.userData.velocity, delta * 60);

    // if very close to center, consider ingested (remove)
    if(dist < 8 && d.userData.life === undefined){
      // small chance to keep some pieces orbiting a bit longer
      if(Math.random() < 0.2) {
        d.userData.life = 3 + Math.random()*4;
      } else {
        debrisGroup.remove(d);
        debrisParticles.splice(i, 1);
      }
    }
  }
}

// ---- lightning ----
function maybeLightning(delta){
  lightningTimer -= delta;
  if(lightningTimer <= 0){
    // next strike in 1..8s
    lightningTimer = 1 + Math.random()*7;
    if(Math.random() < 0.45){ // chance to actually flash
      doLightningStrike();
    }
  }
}
function doLightningStrike(){
  // origin roughly at wallCloud around tornado
  const origin = new THREE.Vector3(
    tornado.position.x + (Math.random()-0.5)*60,
    tornado.position.y + 120 + Math.random()*40,
    tornado.position.z + (Math.random()-0.5)*60
  );
  const strikeX = tornado.position.x + (Math.random()-0.5)*200;
  const strikeZ = tornado.position.z + (Math.random()-0.5)*200;
  const target = new THREE.Vector3(strikeX, 0, strikeZ);

  const segments = 8;
  const pts = [];
  for(let i=0;i<=segments;i++){
    const t = i/segments;
    const y = origin.y * (1 - t); // descend to ground
    const jitterX = (Math.random()-0.5) * 30 * (1 - t);
    const jitterZ = (Math.random()-0.5) * 30 * (1 - t);
    const x = origin.x + (target.x - origin.x) * t + jitterX;
    const z = origin.z + (target.z - origin.z) * t + jitterZ;
    pts.push(new THREE.Vector3(x, y, z));
  }
  const boltGeo = new THREE.BufferGeometry().setFromPoints(pts);
  const boltMat = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
  const bolt = new THREE.Line(boltGeo, boltMat);
  scene.add(bolt);

  // bright flash light near ground impact
  const flash = new THREE.PointLight(0xffffff, 3.2, 900);
  flash.position.copy(target).add(new THREE.Vector3(0, 40, 0));
  scene.add(flash);

  // remove quickly
  setTimeout(()=>{
    scene.remove(bolt);
    scene.remove(flash);
  }, 120 + Math.random()*120);
}

// ---- reset ----
function resetAll(){
  animating = false;

  // reset tornado
  tornado.position.copy(tornadoStart);
  tornado.rotation.set(0,0,0);
  tornado.scale.set(1,1,1);
  tornadoWidth = Number(document.getElementById('widthSlider').value);
  updateWindRadius();

  // clear and recreate scene objects
  houses.forEach(h => scene.remove(h));
  houses.length = 0;
  trees.forEach(t => scene.remove(t));
  trees.length = 0;
  debrisParticles.forEach(d => debrisGroup.remove(d));
  debrisParticles.length = 0;

  setupSceneObjects();
}

// ---- main loop ----
function animate(){
  requestAnimationFrame(animate);
  const now = performance.now();
  const delta = Math.min(0.05, (now - lastTime) / 1000);
  lastTime = now;

  // move tornado when animating
  const moveSpeed = tornadoSpeedMph * 0.06; // tuned mapping mph -> scene units
  if(animating){
    tornado.position.x += moveSpeed * delta * 60;
    // rotate visual faster when stronger winds
    tornado.rotation.y += 0.04 + (windSpeed/200)*0.3;
  }

  // ensure supercell & wall cloud follow tornado (visuals)
  supercell.position.lerp(new THREE.Vector3(tornado.position.x, tornado.position.y + 60, tornado.position.z), 0.05);
  wallCloud.position.lerp(new THREE.Vector3(tornado.position.x, tornado.position.y + 30, tornado.position.z), 0.08);
  supercell.rotation.y += 0.001 * (performanceMode ? 0.5 : 1.0) * (1 + windSpeed/150);

  // apply damage & physics if animating
  if(animating){
    applyDamageAndPhysics(delta);
  } else {
    // still update lightweight debris physics for realism when not animating
    for(let i = debrisParticles.length-1; i >= 0; i--){
      const d = debrisParticles[i];
      d.userData.velocity.y -= 9.8 * 0.02 * delta;
      d.userData.velocity.multiplyScalar(0.995);
      d.position.addScaledVector(d.userData.velocity, delta * 60);
      if(d.userData.life !== undefined){
        d.userData.life -= delta;
        if(d.userData.life <= 0){
          debrisGroup.remove(d);
          debrisParticles.splice(i,1);
        }
      }
    }
  }

  // lightning
  maybeLightning(delta);

  // render
  renderer.render(scene, camera);
}

// initialize wind radius once
updateWindRadius();

</script>
</body>
</html>
