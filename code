<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Optimized 3D Tornado Simulator</title>
<style>
  body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
  #controls {
    position: absolute; top: 10px; left: 10px; background: rgba(255,255,255,0.9);
    padding: 10px; border-radius: 8px; z-index: 10; max-width: 200px;
  }
  #controls input { width: 150px; }
  button { margin: 5px 0; padding: 5px 10px; }
</style>
</head>
<body>
<div id="controls">
  <label>Wind Speed (mph): <span id="windValue">50</span></label><br />
  <input type="range" id="windSlider" min="10" max="331" value="50" /><br />
  <label>Tornado Width: <span id="widthValue">50</span></label><br />
  <input type="range" id="widthSlider" min="10" max="250" value="50" /><br />
  <button id="startBtn">Start</button>
  <button id="resetBtn">Reset</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script>
let scene, camera, renderer;
let tornado, debrisGroup, structures = [], debrisParticles = [];
let tornadoSpeed = 0.5;
let animating = false;

// UI
const windSlider = document.getElementById("windSlider");
const widthSlider = document.getElementById("widthSlider");
const windValue = document.getElementById("windValue");
const widthValue = document.getElementById("widthValue");
windSlider.oninput = () => windValue.textContent = windSlider.value;
widthSlider.oninput = () => {
  widthValue.textContent = widthSlider.value;
  let scale = widthSlider.value / 50;
  tornado.scale.set(scale, scale, scale);
};

// Scene
init();
animate();

function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 5000);
  camera.position.set(0, 200, 400);
  camera.lookAt(0,0,0);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Lights
  scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1));
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
  dirLight.position.set(-100,200,100);
  scene.add(dirLight);

  // Ground
  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(2000,2000),
    new THREE.MeshPhongMaterial({ color: 0x88cc88 })
  );
  ground.rotation.x = -Math.PI/2;
  scene.add(ground);

  // Tornado
  const tornadoGeo = new THREE.CylinderGeometry(5,20,120,16,1,true);
  const tornadoMat = new THREE.MeshStandardMaterial({ color: 0x555555, transparent:true, opacity:0.7 });
  tornado = new THREE.Mesh(tornadoGeo, tornadoMat);
  tornado.position.set(-400,60,0);
  scene.add(tornado);

  // Houses (reduced count for performance)
  for (let i=0;i<20;i++){
    let house = new THREE.Mesh(
      new THREE.BoxGeometry(20,15,20),
      new THREE.MeshStandardMaterial({ color: 0xa0522d })
    );
    house.position.set((Math.random()-0.5)*1500,7.5,(Math.random()-0.5)*1500);
    house.userData.damaged=false;
    scene.add(house);
    structures.push(house);
  }

  // Debris (lighter: 100 particles only)
  debrisGroup = new THREE.Group();
  scene.add(debrisGroup);
  for (let i=0;i<100;i++){
    let d = new THREE.Mesh(
      new THREE.BoxGeometry(1,1,1),
      new THREE.MeshStandardMaterial({ color:0x888888 })
    );
    d.position.set((Math.random()-0.5)*800,Math.random()*100,(Math.random()-0.5)*800);
    d.userData.velocity=new THREE.Vector3();
    debrisGroup.add(d);
    debrisParticles.push(d);
  }

  // Buttons
  document.getElementById("startBtn").onclick=()=>{ animating=true; resetStructures(); };
  document.getElementById("resetBtn").onclick=()=>{ animating=false; resetStructures(); resetDebris(); };

  window.addEventListener("resize",()=>{
    camera.aspect=window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth,window.innerHeight);
  });
}

function resetStructures(){
  structures.forEach(s=>{
    s.userData.damaged=false;
    s.material.color.set(0xa0522d);
    s.material.opacity=1;
  });
}
function resetDebris(){
  debrisParticles.forEach(d=>{
    d.position.set((Math.random()-0.5)*800,Math.random()*100,(Math.random()-0.5)*800);
    d.userData.velocity.set(0,0,0);
  });
}

function animate(){
  requestAnimationFrame(animate);
  if(animating){
    tornado.position.x += (windSlider.value/50)*tornadoSpeed;
    tornado.rotation.y += 0.05;

    // Structure damage check (only if close)
    structures.forEach(s=>{
      if(!s.userData.damaged){
        let dist = s.position.distanceTo(tornado.position);
        if(dist < 30){
          s.userData.damaged=true;
          s.material.color.set(0x555555);
          s.material.opacity=0.5;
        }
      }
    });

    // Debris movement
    debrisParticles.forEach(d=>{
      let dir = new THREE.Vector3().subVectors(tornado.position,d.position);
      let dist = dir.length();
      if(dist<200){
        dir.normalize();
        d.userData.velocity.add(dir.multiplyScalar(0.1));
        d.userData.velocity.y -= 0.003;
        d.position.add(d.userData.velocity);
      }
    });
  }
  renderer.render(scene,camera);
}
</script>
</body>
</html>
