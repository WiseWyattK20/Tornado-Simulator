<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Advanced 3D Tornado Simulator</title>
<style>
  html, body { margin:0; height:100%; overflow:hidden; background:#2f2f35; font-family:Arial, sans-serif; }
  #controls { position:absolute; top:10px; left:10px; z-index:50; background:rgba(255,255,255,0.95); padding:10px; border-radius:8px; width:280px; }
  #controls input[type=range] { width:190px; }
  button { margin-top:6px; padding:6px 10px; }
</style>
</head>
<body>
<div id="controls">
  <label>Wind Speed (mph): <strong id="windValue">50</strong></label><br>
  <input id="windSlider" type="range" min="10" max="200" value="50"><br>
  <label>Tornado Speed (mph): <strong id="speedValue">20</strong></label><br>
  <input id="speedSlider" type="range" min="1" max="90" value="20"><br>
  <label>Tornado Width: <strong id="widthValue">50</strong></label><br>
  <input id="widthSlider" type="range" min="10" max="300" value="50"><br>
  <label>Performance Mode (auto):</label>
  <input id="perfToggle" type="checkbox" checked><br>
  <button id="startBtn">Start (drop funnel)</button>
  <button id="resetBtn">Reset</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script>
let scene, camera, renderer;
let tornado, tornadoStart={x:-400,y:320,z:0};
let debrisGroup;
let houses=[], trees=[], debrisPieces=[];
let wallCloud, stormClouds=[];
let animating=false, dropping=false;
let windSpeed=50, tornadoSpeedMph=20, tornadoWidth=50;
let tornadoWindRadius=150;
const damageThreshold=75;
let performanceMode=true, lightningTimer=0;

// UI
const windSlider=document.getElementById('windSlider');
const speedSlider=document.getElementById('speedSlider');
const widthSlider=document.getElementById('widthSlider');
const windValue=document.getElementById('windValue');
const speedValue=document.getElementById('speedValue');
const widthValue=document.getElementById('widthValue');
const perfToggle=document.getElementById('perfToggle');

windSlider.oninput=()=>{windValue.textContent=windSlider.value; windSpeed=Number(windSlider.value);}
speedSlider.oninput=()=>{speedValue.textContent=speedSlider.value; tornadoSpeedMph=Number(speedSlider.value);}
widthSlider.oninput=()=>{widthValue.textContent=widthSlider.value; tornadoWidth=Number(widthSlider.value); updateWindRadius(); adjustTornadoScale();}
perfToggle.onchange=()=>{performanceMode=perfToggle.checked; applyPerformanceMode(); recreateSceneObjects();}

document.getElementById('startBtn').onclick=startDrop;
document.getElementById('resetBtn').onclick=resetAll;

// Scene init
init();
animate();

function init(){
  scene=new THREE.Scene();
  scene.background=new THREE.Color(0x3a3a3a); // dark stormy gray
  scene.fog=new THREE.Fog(0x3a3a3a, 500, 4200);

  camera=new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 6000);
  camera.position.set(0,250,520);
  camera.lookAt(0,60,0);

  renderer=new THREE.WebGLRenderer({antialias:!performanceMode});
  renderer.setSize(innerWidth,innerHeight);
  renderer.setPixelRatio(performanceMode?Math.min(window.devicePixelRatio||1,1):Math.min(window.devicePixelRatio||1.5,2));
  document.body.appendChild(renderer.domElement);

  // Lighting
  const hemi=new THREE.HemisphereLight(0x555555,0x222222,0.9);
  scene.add(hemi);
  const dir=new THREE.DirectionalLight(0xffffff,0.6);
  dir.position.set(-100,300,100);
  scene.add(dir);

  // Ground
  const groundMat=new THREE.MeshPhongMaterial({color:0x1f4d1f});
  const ground=new THREE.Mesh(new THREE.PlaneGeometry(2000,2000), groundMat);
  ground.rotation.x=-Math.PI/2;
  scene.add(ground);

  // Tornado
  const torGeo=new THREE.CylinderGeometry(20,5,120,16,1,true);
  const torMat=new THREE.MeshStandardMaterial({color:0x555555,transparent:true,opacity:0.7});
  tornado=new THREE.Mesh(torGeo,torMat);
  tornado.position.set(tornadoStart.x,tornadoStart.y,tornadoStart.z);
  scene.add(tornado);

  // Wall cloud (stationary)
  wallCloud=new THREE.Group();
  const cloudGeo=new THREE.SphereGeometry(100,16,16);
  const cloudMat=new THREE.MeshStandardMaterial({color:0x333333,transparent:true,opacity:0.4});
  for(let i=0;i<8;i++){
    const c=new THREE.Mesh(cloudGeo,cloudMat);
    c.position.set((Math.random()-0.5)*300,50+(Math.random()*50), (Math.random()-0.5)*300);
    cloudMat.opacity=0.4;
    wallCloud.add(c);
  }
  scene.add(wallCloud);

  // Storm clouds (replace supercell)
  stormClouds=[];
  const stormGeo=new THREE.SphereGeometry(80,16,16);
  const stormMat=new THREE.MeshStandardMaterial({color:0x2f2f2f,transparent:true,opacity:0.25});
  for(let i=0;i<50;i++){
    const c=new THREE.Mesh(stormGeo,stormMat);
    c.position.set((Math.random()-0.5)*1800,50+(Math.random()*100), (Math.random()-0.5)*1800);
    scene.add(c);
    stormClouds.push(c);
  }

  debrisGroup=new THREE.Group();
  scene.add(debrisGroup);

  // Create scene objects
  recreateSceneObjects();

  window.addEventListener("resize",()=>{
    camera.aspect=innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth,innerHeight);
  });
}

// Updates tornado wind radius with width
function updateWindRadius(){ tornadoWindRadius=tornadoWidth*3; }
function adjustTornadoScale(){ tornado.scale.set(tornadoWidth/50,1,tornadoWidth/50); }

// Performance mode adjustment
function applyPerformanceMode(){ recreateSceneObjects(); }

// Creates houses, trees, debris
function recreateSceneObjects(){
  houses.forEach(h=>scene.remove(h));
  trees.forEach(t=>scene.remove(t));
  debrisPieces.forEach(d=>debrisGroup.remove(d));
  houses=[]; trees=[]; debrisPieces=[];

  const houseCount=performanceMode?10:20;
  const treeCount=performanceMode?20:50;
  const debrisCount=performanceMode?50:200;

  // Houses
  for(let i=0;i<houseCount;i++){
    let house=new THREE.Group();
    let base=new THREE.Mesh(new THREE.BoxGeometry(20,10,20), new THREE.MeshStandardMaterial({color:0xa0522d}));
    let roof=new THREE.Mesh(new THREE.ConeGeometry(15,6,4), new THREE.MeshStandardMaterial({color:0x8b0000}));
    roof.position.y=8;
    house.add(base); house.add(roof);
    house.position.set((Math.random()-0.5)*1500,5,(Math.random()-0.5)*1500);
    house.userData.damagedParts=[];
    scene.add(house); houses.push(house);
  }

  // Trees
  for(let i=0;i<treeCount;i++){
    let trunk=new THREE.Mesh(new THREE.CylinderGeometry(1,1,5,6), new THREE.MeshStandardMaterial({color:0x8b4513}));
    let leaves=new THREE.Mesh(new THREE.ConeGeometry(3,10,8), new THREE.MeshStandardMaterial({color:0x228B22}));
    let tree=new THREE.Group(); trunk.position.y=2.5; leaves.position.y=8; tree.add(trunk); tree.add(leaves);
    tree.position.set((Math.random()-0.5)*1500,0,(Math.random()-0.5)*1500);
    tree.userData.damagedParts=[];
    scene.add(tree); trees.push(tree);
  }

  // Debris
  for(let i=0;i<debrisCount;i++){
    let d=new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({color:0x888888}));
    d.position.set((Math.random()-0.5)*800,Math.random()*100,(Math.random()-0.5)*800);
    d.userData.velocity=new THREE.Vector3();
    debrisGroup.add(d); debrisPieces.push(d);
  }
}

// Start tornado funnel drop
function startDrop(){
  animating=true; dropping=true;
  tornado.position.set(tornadoStart.x,tornadoStart.y,tornadoStart.z);
}

// Reset scene
function resetAll(){
  animating=false; dropping=false;
  tornado.position.set(tornadoStart.x,tornadoStart.y,tornadoStart.z);
  recreateSceneObjects();
}

// Animate
function animate(){
  requestAnimationFrame(animate);

  if(animating){
    // Funnel drop
    if(dropping){
      tornado.position.y-=2;
      if(tornado.position.y<=60){ dropping=false; }
    }

    // Tornado forward motion
    if(!dropping) tornado.position.x+=tornadoSpeedMph/2;

    // Procedural damage and debris suction
    houses.concat(trees).forEach(obj=>{
      const dist=tornado.position.distanceTo(obj.position);
      if(dist<tornadoWindRadius && windSpeed>=damageThreshold){
        obj.children.forEach(c=>{
          if(!obj.userData.damagedParts.includes(c)){
            c.position.y-=Math.random()*1.5;
            c.rotation.x+=(Math.random()-0.5)*0.5;
            c.rotation.z+=(Math.random()-0.5)*0.5;
            obj.userData.damagedParts.push(c);
            debrisPieces.forEach(d=>{
              const dDist=tornado.position.distanceTo(d.position);
              if(dDist<tornadoWindRadius*1.5){
                const dir=new THREE.Vector3().subVectors(tornado.position,d.position).normalize().multiplyScalar(0.2);
                d.userData.velocity.add(dir);
              }
            });
          }
        });
      }
    });

    // Debris physics
    debrisPieces.forEach(d=>{
      d.userData.velocity.y-=0.01;
      d.position.add(d.userData.velocity);
    });

    // Lightning
    lightningTimer--;
    if(lightningTimer<=0 && Math.random()<0.01){
      lightningTimer=60+Math.random()*100;
      scene.background=new THREE.Color(0xffffff);
      setTimeout(()=>{scene.background=new THREE.Color(0x3a3a3a);},50);
    }
  }

  renderer.render(scene,camera);
}
</script>
</body>
</html>
