<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Advanced 3D Tornado Simulator</title>
<style>
  body { margin:0; overflow:hidden; font-family: Arial, sans-serif; background:#888;}
  #controls {
    position:absolute; top:10px; left:10px; background: rgba(255,255,255,0.9);
    padding:10px; border-radius:8px; z-index:10; max-width:250px;
  }
  #controls input { width:160px; }
  button { margin:5px 0; padding:5px 10px; }
  #toggleUI { position:absolute; top:10px; right:10px; z-index:10; }
  #efLabel { position:absolute; bottom:10px; left:10px; z-index:10; font-weight:bold; color:#fff; }
</style>
</head>
<body>
<div id="controls">
  <label>Wind Speed (mph): <span id="windValue">50</span></label><br>
  <input type="range" id="windSlider" min="10" max="331" value="50"><br>

  <label>Tornado Speed (mph): <span id="speedValue">10</span></label><br>
  <input type="range" id="speedSlider" min="1" max="90" value="10"><br>

  <label>Tornado Width: <span id="widthValue">50</span></label><br>
  <input type="range" id="widthSlider" min="10" max="4200" value="50"><br>

  <label>Performance Mode:</label> <input type="checkbox" id="perfToggle" checked><br>
  <label>Phone Mode:</label> <input type="checkbox" id="phoneToggle"><br>

  <button id="startBtn">Start</button>
  <button id="resetBtn">Reset</button>
</div>
<button id="toggleUI">Toggle UI</button>
<div id="efLabel">EF0</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script>
let scene, camera, renderer;
let tornado, funnel, wallCloud, stormBase;
let debrisGroup = [], dustGroup = [];
let houses = [], trees = [], roads = [], streetLights = [], powerLines = [], shelters = [];
let animating = false;
let windSpeed = 50;
let tornadoSpeed = 10;
let tornadoWidth = 50;
let performanceMode = true;
let phoneMode = false;
let ground;
let efScale = 0;

// UI Elements
const windSlider = document.getElementById("windSlider");
const speedSlider = document.getElementById("speedSlider");
const widthSlider = document.getElementById("widthSlider");
const windValue = document.getElementById("windValue");
const speedValue = document.getElementById("speedValue");
const widthValue = document.getElementById("widthValue");
const perfToggle = document.getElementById("perfToggle");
const phoneToggle = document.getElementById("phoneToggle");
const toggleUI = document.getElementById("toggleUI");
const controls = document.getElementById("controls");
const efLabel = document.getElementById("efLabel");

windSlider.oninput = ()=> { windValue.textContent = windSlider.value; windSpeed = Number(windSlider.value); };
speedSlider.oninput = ()=> { speedValue.textContent = speedSlider.value; tornadoSpeed = Number(speedSlider.value)/1; };
widthSlider.oninput = ()=> { widthValue.textContent = widthSlider.value; tornadoWidth = Number(widthSlider.value); tornado.scale.set(tornadoWidth/50,1,tornadoWidth/50); };
perfToggle.onchange = ()=> { performanceMode = perfToggle.checked; setupSceneObjects(); };
phoneToggle.onchange = ()=> { phoneMode = phoneToggle.checked; setupSceneObjects(); };
toggleUI.onclick = ()=> { controls.style.display = controls.style.display === "none" ? "block" : "none"; };

// Scene Init
init();
animate();

function init(){
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x888888);

  camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 5000);
  camera.position.set(0,200,400);
  camera.lookAt(0,0,0);

  renderer = new THREE.WebGLRenderer({ antialias: !performanceMode });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Lights
  scene.add(new THREE.HemisphereLight(0xffffff,0x444444,1));
  const dirLight = new THREE.DirectionalLight(0xffffff,0.8);
  dirLight.position.set(-100,200,100);
  scene.add(dirLight);

  // Ground
  const groundMat = new THREE.MeshPhongMaterial({color:0x2c3e2c});
  ground = new THREE.Mesh(new THREE.PlaneGeometry(2000,2000), groundMat);
  ground.rotation.x = -Math.PI/2;
  scene.add(ground);

  // Tornado funnel
  const torGeo = new THREE.CylinderGeometry(20,5,120,16,1,true);
  const torMat = new THREE.MeshStandardMaterial({color:0x555555, transparent:true, opacity:0.7});
  tornado = new THREE.Mesh(torGeo, torMat);
  tornado.position.set(-400,60,0);
  scene.add(tornado);

  // Funnel cloud (attached to tornado)
  const funnelGeo = new THREE.ConeGeometry(25,60,16);
  const funnelMat = new THREE.MeshStandardMaterial({color:0x333333, transparent:true, opacity:0.6});
  funnel = new THREE.Mesh(funnelGeo, funnelMat);
  funnel.position.set(0,60,0);
  tornado.add(funnel);

  // Wall cloud
  const wallGeo = new THREE.CylinderGeometry(80,60,20,32);
  const wallMat = new THREE.MeshStandardMaterial({color:0x444444, transparent:true, opacity:0.5});
  wallCloud = new THREE.Mesh(wallGeo, wallMat);
  wallCloud.position.set(0,120,0);
  tornado.add(wallCloud);

  // Storm base
  const baseGeo = new THREE.CylinderGeometry(300,300,20,32);
  const baseMat = new THREE.MeshStandardMaterial({color:0x222222, transparent:true, opacity:0.4});
  stormBase = new THREE.Mesh(baseGeo, baseMat);
  stormBase.position.set(0,10,0);
  scene.add(stormBase);

  debrisGroup = new THREE.Group();
  scene.add(debrisGroup);

  dustGroup = new THREE.Group();
  scene.add(dustGroup);

  // Buttons
  document.getElementById("startBtn").onclick = ()=> { animating=true; resetScene(); };
  document.getElementById("resetBtn").onclick = ()=> { animating=false; resetScene(); };

  window.addEventListener("resize",()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  setupSceneObjects();
}

// Setup procedural objects
function setupSceneObjects(){
  // Clear previous
  houses.forEach(h=>scene.remove(h)); houses=[];
  trees.forEach(t=>scene.remove(t)); trees=[];
  debrisGroup.children.forEach(d=>debrisGroup.remove(d)); 
  roads.forEach(r=>scene.remove(r)); roads=[];
  streetLights.forEach(l=>scene.remove(l)); streetLights=[];
  powerLines.forEach(p=>scene.remove(p)); powerLines=[];
  shelters.forEach(s=>scene.remove(s)); shelters=[];
  dustGroup.children.forEach(d=>dustGroup.remove(d));

  let houseCount = phoneMode?5:performanceMode?10:20;
  let treeCount = phoneMode?10:performanceMode?20:50;
  let debrisCount = phoneMode?30:performanceMode?50:200;

  // Procedural Roads, Houses, Trees, Lights, Powerlines, Shelters
  for(let i=0;i<houseCount;i++){
    let house = createDestructibleHouse();
    house.position.set((Math.random()-0.5)*1500,0,(Math.random()-0.5)*1500);
    scene.add(house); houses.push(house);

    // Road
    let road = new THREE.Mesh(new THREE.PlaneGeometry(30,50), new THREE.MeshPhongMaterial({color:0x555555}));
    road.rotation.x=-Math.PI/2; road.position.set(house.position.x,0,house.position.z-30);
    scene.add(road); roads.push(road);

    // Streetlight
    let light = new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.5,15,6), new THREE.MeshStandardMaterial({color:0xffff00}));
    light.position.set(house.position.x+10,7.5,house.position.z-25);
    scene.add(light); streetLights.push(light);

    // Powerline
    let pole = new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.5,10,6), new THREE.MeshStandardMaterial({color:0x888888}));
    pole.position.set(house.position.x-10,5,house.position.z-25);
    scene.add(pole); powerLines.push(pole);

    // Shelter
    let shelter = new THREE.Mesh(new THREE.BoxGeometry(10,10,10), new THREE.MeshStandardMaterial({color:0x666666}));
    shelter.position.set(house.position.x+15,5,house.position.z+15);
    shelter.userData.resistance = Math.random()<0.8?209:243;
    scene.add(shelter); shelters.push(shelter);
  }

  // Trees
  for(let i=0;i<treeCount;i++){
    let trunk = new THREE.Mesh(new THREE.CylinderGeometry(1,1,5,6), new THREE.MeshStandardMaterial({color:0x8b4513}));
    let leaves = new THREE.Mesh(new THREE.ConeGeometry(3,10,8), new THREE.MeshStandardMaterial({color:0x228B22}));
    let tree = new THREE.Group(); trunk.position.y=2.5; leaves.position.y=8;
    tree.add(trunk); tree.add(leaves);
    tree.position.set((Math.random()-0.5)*1500,0,(Math.random()-0.5)*1500);
    tree.userData.damagedParts=[];
    scene.add(tree); trees.push(tree);
  }

  // Initial debris
  for(let i=0;i<debrisCount;i++){
    let d = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({color:0x888888}));
    d.position.set((Math.random()-0.5)*800,Math.random()*100,(Math.random()-0.5)*800);
    d.userData.velocity = new THREE.Vector3();
    debrisGroup.add(d);
  }
}

// Create a destructible house
function createDestructibleHouse(){
  let group = new THREE.Group();
  group.userData.fragments = [];
  // Walls
  for(let i=0;i<4;i++){
    let wall = new THREE.Mesh(new THREE.BoxGeometry(10,10,1), new THREE.MeshStandardMaterial({color:0xa0522d}));
    wall.position.set(i<2?0:5,5,i%2?0:5);
    group.add(wall); group.userData.fragments.push(wall);
  }
  // Roof
  for(let i=0;i<4;i++){
    let roof = new THREE.Mesh(new THREE.ConeGeometry(7,5,4), new THREE.MeshStandardMaterial({color:0x8b0000}));
    roof.position.set(i<2?0:5,10,i%2?0:5);
    group.add(roof); group.userData.fragments.push(roof);
  }
  group.userData.damagedFragments = [];
  return group;
}

// Reset Scene
function resetScene(){
  tornado.position.set(-400,60,0);
  houses.forEach(h=>h.userData.damagedFragments=[]);
  trees.forEach(t=>t.userData.damagedParts=[]);
  debrisGroup.children.forEach(d=>d.userData.velocity.set(0,0,0));
}

// Animate loop
function animate(){
  requestAnimationFrame(animate);

  if(animating){
    tornado.position.x += tornadoSpeed;
    tornado.rotation.y += 0.05;

    updateHouses();
    updateTrees();
    updateDebris();
    updateDust();
    updateShelters();
    updateEFScale();
  }

  renderer.render(scene,camera);
}

// Update houses with realistic destruction
function updateHouses(){
  houses.forEach(h=>{
    let dist = h.position.distanceTo(tornado.position);
    if(dist<tornadoWidth*2){
      h.userData.fragments.forEach(f=>{
        if(Math.random()*windSpeed>30 && !h.userData.damagedFragments.includes(f)){
          // Detach fragment and apply velocity
          f.position.add(new THREE.Vector3((Math.random()-0.5)*5,Math.random()*2,(Math.random()-0.5)*5));
          let v = new THREE.Vector3((Math.random()-0.5)*0.5,Math.random()*0.5,(Math.random()-0.5)*0.5);
          f.userData = {velocity:v};
          debrisGroup.add(f);
          h.userData.damagedFragments.push(f);
        }
      });
    }
  });
}

// Update trees similarly
function updateTrees(){
  trees.forEach(t=>{
    let dist = t.position.distanceTo(tornado.position);
    if(dist<tornadoWidth*2){
      t.children.forEach(c=>{
        if(Math.random()*windSpeed>25 && !t.userData.damagedParts.includes(c)){
          c.rotation.x += (Math.random()-0.5)*0.5;
          c.rotation.z += (Math.random()-0.5)*0.5;
          t.userData.damagedParts.push(c);

          let debris = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({color:c.material.color}));
          debris.position.copy(c.getWorldPosition(new THREE.Vector3()));
          debris.userData.velocity = new THREE.Vector3((Math.random()-0.5)*0.5,Math.random()*0.5,(Math.random()-0.5)*0.5);
          debrisGroup.add(debris);
        }
      });
    }
  });
}

// Update debris
function updateDebris(){
  debrisGroup.children.forEach(d=>{
    if(!d.userData.velocity) d.userData.velocity = new THREE.Vector3();
    let dir = new THREE.Vector3().subVectors(tornado.position,d.position);
    let dist = dir.length();
    if(dist<tornadoWidth*4){
      dir.normalize();
      let factor = windSpeed/50 * (1-dist/(tornadoWidth*4));
      d.userData.velocity.add(dir.multiplyScalar(0.2*factor));
      d.userData.velocity.y -= 0.01;
    }
    d.position.add(d.userData.velocity);
  });
}

// Update dust
function updateDust(){
  // generate dust under tornado
  for(let i=0;i<5;i++){
    let dust = new THREE.Mesh(new THREE.SphereGeometry(1,4,4), new THREE.MeshStandardMaterial({color:0xaaaaaa, transparent:true, opacity:0.5}));
    dust.position.set(tornado.position.x + (Math.random()-0.5)*tornadoWidth*2,1,tornado.position.z + (Math.random()-0.5)*tornadoWidth*2);
    dust.userData.velocity = new THREE.Vector3((Math.random()-0.5)*0.2,0,(Math.random()-0.5)*0.2);
    dustGroup.add(dust);
  }
  dustGroup.children.forEach(d=>{
    d.position.add(d.userData.velocity);
  });
}

// Update shelters
function updateShelters(){
  shelters.forEach(s=>{
    let dist = s.position.distanceTo(tornado.position);
    if(dist<s.userData.resistance/2){
      s.material.color.set(0xff0000);
    }else{
      s.material.color.set(0x666666);
    }
  });
}

// Update EF scale
function updateEFScale(){
  efScale = Math.min(5, Math.floor(windSpeed/66)); // approximate EF0-EF5
  efLabel.textContent = `EF${efScale}`;
}

</script>
</body>
</html>
