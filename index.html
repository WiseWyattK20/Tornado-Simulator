<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tornado Simulator â€” Full Storm, Procedural Damage</title>
<style>
  html,body{height:100%;margin:0}
  body{font-family:Arial,Helvetica,sans-serif;overflow:hidden;background:#444}
  #controls{
    position:absolute;left:10px;top:10px;z-index:50;background:rgba(255,255,255,0.95);
    padding:10px;border-radius:8px;width:280px;box-shadow:0 6px 18px rgba(0,0,0,0.2)
  }
  #controls input[type=range]{width:190px}
  button{margin-top:6px;padding:6px 10px}
  #status{position:absolute;right:12px;top:12px;z-index:50;color:#111;background:rgba(255,255,255,0.9);padding:6px 8px;border-radius:6px;font-size:13px}
</style>
</head>
<body>
<div id="controls">
  <label>Wind Speed (mph): <strong id="windValue">50</strong></label><br>
  <input id="windSlider" type="range" min="10" max="200" value="50"><br>

  <label>Tornado Speed (mph): <strong id="speedValue">20</strong></label><br>
  <input id="speedSlider" type="range" min="1" max="90" value="20"><br>

  <label>Tornado Width: <strong id="widthValue">50</strong></label><br>
  <input id="widthSlider" type="range" min="10" max="300" value="50"><br>

  <label>Performance Mode (auto):</label>
  <input id="perfToggle" type="checkbox" checked><br>

  <button id="startBtn">Start (drop funnel)</button>
  <button id="resetBtn">Reset</button>
</div>

<div id="status">Perf: <span id="perfState">AUTO</span></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script>
/*
  Full update implementing:
  - Full-map supercell (rotating)
  - Tornado funnel drop, touches ground, then moves
  - More realistic funnel (stacked torus rings + inner particles)
  - Ground scour via canvas radial texture, stronger near core
  - Procedural continuous damage while windSpeed >= damageThreshold (75 mph)
  - Houses fully destructible (many small blocks), trees destructible
  - Debris spawns from destroyed parts and is sucked into vortex
  - Lightning originates from storm and strikes ground
  - Reset fully restores everything
  - Performance mode auto-detected but toggleable
*/

// === Config / state ===
let scene, camera, renderer;
let tornado, tornadoStart = {x:-400,y:320,z:0}, funnelInnerParticles;
let debrisGroup;
let houses = [], trees = [], debrisPieces = [];
let supercell, wallCloud;
let animating = false;
let dropping = false;
let windSpeed = 50;         // UI
let tornadoSpeedMph = 20;   // UI
let tornadoWidth = 50;      // UI
let tornadoWindRadius = 150;
const damageThreshold = 75; // damage applied while windSpeed >= this
let performanceMode = true;
let lastT = performance.now();
let lightningTimer = 0;

// UI bindings
const windSlider = document.getElementById('windSlider');
const speedSlider = document.getElementById('speedSlider');
const widthSlider = document.getElementById('widthSlider');
const windValue = document.getElementById('windValue');
const speedValue = document.getElementById('speedValue');
const widthValue = document.getElementById('widthValue');
const perfToggle = document.getElementById('perfToggle');
const perfState = document.getElementById('perfState');

windSlider.oninput = ()=> { windValue.textContent = windSlider.value; windSpeed = Number(windSlider.value); };
speedSlider.oninput = ()=> { speedValue.textContent = speedSlider.value; tornadoSpeedMph = Number(speedSlider.value); };
widthSlider.oninput = ()=> { widthValue.textContent = widthSlider.value; tornadoWidth = Number(widthSlider.value); updateWindRadius(); adjustTornadoVisualScale(); };
perfToggle.onchange = ()=> { performanceMode = perfToggle.checked; applyPerformanceMode(); recreateSceneObjects(); };

document.getElementById('startBtn').onclick = startDrop;
document.getElementById('resetBtn').onclick = resetAll;

// auto perf detection
function detectPerf(){
  let mem = navigator.deviceMemory || 4;
  let ua = navigator.userAgent || '';
  let isMobile = /Mobi|Android|iPhone|iPad|iPod|Windows Phone/i.test(ua);
  performanceMode = (mem <= 2 || isMobile);
  perfToggle.checked = performanceMode;
  perfState.textContent = performanceMode ? 'ON' : 'OFF';
}
detectPerf();

function applyPerformanceMode(){
  perfState.textContent = performanceMode ? 'ON' : 'OFF';
  if(renderer) renderer.setPixelRatio(performanceMode ? Math.min(window.devicePixelRatio||1,1) : Math.min(window.devicePixelRatio||1.5,2));
}

// === Three init ===
init();
animate();

function init(){
  scene = new THREE.Scene();
  // dark gray storm sky
  scene.background = new THREE.Color(0x2f2f35);

  camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 6000);
  camera.position.set(0,250,520);
  camera.lookAt(0,60,0);

  renderer = new THREE.WebGLRenderer({ antialias: !performanceMode });
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(performanceMode ? Math.min(window.devicePixelRatio||1,1) : Math.min(window.devicePixelRatio||1.5,2));
  document.body.appendChild(renderer.domElement);

  window.addEventListener('resize', ()=> {
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  // Lights (darker overall)
  const hemi = new THREE.HemisphereLight(0x616266, 0x333333, 0.6);
  scene.add(hemi);
  const sun = new THREE.DirectionalLight(0xddddff, 0.35);
  sun.position.set(-200,300,150);
  scene.add(sun);

  // Ground (darker green)
  const groundMat = new THREE.MeshPhongMaterial({color:0x3a6b3a});
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(3000,3000,2,2), groundMat);
  ground.rotation.x = -Math.PI/2;
  scene.add(ground);

  // ground scour overlay (canvas texture)
  createScourOverlay();

  // Tornado visual (stacked torus rings)
  createTornadoVisual();

  // debris group
  debrisGroup = new THREE.Group();
  scene.add(debrisGroup);

  // supercell (full-map)
  createSupercellLarge();

  // wall cloud
  createWallCloud();

  // initial objects
  applyPerformanceMode();
  recreateSceneObjects();
  updateWindRadius();
}

// === Visual tornado: stacked torus rings + inner point particles ===
function createTornadoVisual(){
  tornado = new THREE.Group();
  // rings from top to bottom, decreasing radius
  const ringCount = 28;
  for(let i=0;i<ringCount;i++){
    const t = Math.max(2, 40 - i*1.3);
    const tube = 1.8;
    const ringGeo = new THREE.TorusGeometry(t, tube, 8, 60);
    ringGeo.rotateX(Math.PI/2);
    // shift ring down along y
    const y = (ringCount - i) * 6; // spacing
    ringGeo.translate(0,y,0);
    const mat = new THREE.MeshStandardMaterial({ color:0x222222, transparent:true, opacity: 0.65 - (i/ringCount)*0.45, side:THREE.DoubleSide });
    const mesh = new THREE.Mesh(ringGeo, mat);
    mesh.userData.ringIndex = i;
    tornado.add(mesh);
  }
  // bring base down so bottom rests near y=0
  tornado.position.set(tornadoStart.x, tornadoStart.y, tornadoStart.z);
  scene.add(tornado);

  // inner particles (low-cost Points)
  const pts = new THREE.BufferGeometry();
  const n = 600;
  const positions = new Float32Array(n*3);
  for(let i=0;i<n;i++){
    positions[i*3+0] = (Math.random()-0.5) * 24;
    positions[i*3+1] = Math.random()*200;
    positions[i*3+2] = (Math.random()-0.5) * 24;
  }
  pts.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  const pMat = new THREE.PointsMaterial({ size:1.6, color:0xaaaaaa, transparent:true, opacity:0.9 });
  funnelInnerParticles = new THREE.Points(pts, pMat);
  tornado.add(funnelInnerParticles);
}

// === Supercell (large) ===
function createSupercellLarge(){
  supercell = new THREE.Group();
  // add many low-poly flattened spheres across the map to cover it
  const count = performanceMode ? 18 : 36;
  for(let i=0;i<count;i++){
    const radius = 300 + Math.random()*900;
    const geo = new THREE.SphereGeometry(radius, 8, 6);
    geo.scale(1, 0.35, 1.6);
    const mat = new THREE.MeshLambertMaterial({ color:0x222426, transparent:true, opacity: 0.28 });
    const m = new THREE.Mesh(geo, mat);
    m.position.set((Math.random()-0.5)*1200, 160 + Math.random()*80, (Math.random()-0.5)*1200);
    m.rotation.y = Math.random()*Math.PI*2;
    supercell.add(m);
  }
  scene.add(supercell);
}

// === Wall cloud (localized under supercell) ===
function createWallCloud(){
  wallCloud = new THREE.Group();
  const geo = new THREE.CylinderGeometry(180, 300, 60, 24, 1, true);
  geo.translate(0, 30, 0);
  const mat = new THREE.MeshLambertMaterial({ color: 0x1b1b1f, transparent:true, opacity: 0.48, side:THREE.DoubleSide });
  const mesh = new THREE.Mesh(geo, mat);
  wallCloud.add(mesh);
  scene.add(wallCloud);
}

// === Scour overlay: dynamic canvas texture painted each frame ===
let scourCanvas, scourTexture, scourMesh;
function createScourOverlay(){
  const size = 2048; // big canvas for decent resolution
  scourCanvas = document.createElement('canvas');
  scourCanvas.width = size; scourCanvas.height = size;
  scourTexture = new THREE.CanvasTexture(scourCanvas);
  scourTexture.wrapS = scourTexture.wrapT = THREE.ClampToEdgeWrapping;
  const mat = new THREE.MeshBasicMaterial({ map: scourTexture, transparent:true, opacity:1, depthWrite:false });
  const plane = new THREE.PlaneGeometry(3000,3000);
  scourMesh = new THREE.Mesh(plane, mat);
  scourMesh.rotation.x = -Math.PI/2;
  scourMesh.position.y = 0.01; // slightly above ground to avoid z-fighting
  scene.add(scourMesh);
  // init empty
  paintScourTexture();
}

// draw a radial gradient centered at tornado pos; darker near core; resets when wind reduced
function paintScourTexture(){
  const ctx = scourCanvas.getContext('2d');
  // clear to transparent (no scour)
  ctx.clearRect(0,0,scourCanvas.width,scourCanvas.height);
  // convert tornado world coords to canvas coords
  const mapSize = 3000;
  const cx = (scourCanvas.width/2) + (tornado.position.x / mapSize) * scourCanvas.width;
  const cy = (scourCanvas.height/2) - (tornado.position.z / mapSize) * scourCanvas.height;
  // radius based on tornadoWindRadius and windSpeed
  const baseRadius = (tornadoWindRadius / mapSize) * scourCanvas.width * (1 + windSpeed/150);
  // create radial gradient
  const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, baseRadius);
  // inner darkest brown
  const innerAlpha = Math.min(0.95, (windSpeed / 200) * 1.6);
  grad.addColorStop(0, `rgba(66,35,11,${innerAlpha})`); // dark soil
  // mid
  grad.addColorStop(0.4, `rgba(94,52,22,${innerAlpha*0.7})`);
  // outer fades to transparent
  grad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,scourCanvas.width,scourCanvas.height);
  scourTexture.needsUpdate = true;
}

// === scene objects (houses/trees/debris) ===
function recreateSceneObjects(){
  // clear previous
  houses.forEach(h=>scene.remove(h)); houses = [];
  trees.forEach(t=>scene.remove(t)); trees = [];
  debrisPieces.forEach(d=>debrisGroup.remove(d)); debrisPieces = [];

  // counts depend on performance mode
  const houseCount = performanceMode ? 8 : 20;
  const treeCount  = performanceMode ? 28 : 80;
  const ambientDebris = performanceMode ? 60 : 220;

  // Houses: build from many bricks and roof tiles for procedural removal
  for(let i=0;i<houseCount;i++){
    const house = new THREE.Group();
    const baseGroup = new THREE.Group();
    const w = 18, h = 10, d = 14;
    // build walls as small bricks (grid)
    const brickSize = 3;
    const xCount = Math.floor(w/brickSize);
    const zCount = Math.floor(d/brickSize);
    for(let xi=0; xi<xCount; xi++){
      for(let zi=0; zi<zCount; zi++){
        // two wall layers leaving space for doorway randomly
        const brick = new THREE.Mesh(new THREE.BoxGeometry(brickSize, h-2, brickSize), new THREE.MeshStandardMaterial({ color: 0xb76a3a }));
        brick.position.set((xi - (xCount-1)/2) * brickSize, (h/2)-1, (zi - (zCount-1)/2)*brickSize);
        // small chance to be a window (we still destroy them)
        baseGroup.add(brick);
      }
    }
    baseGroup.position.y = 0;
    house.add(baseGroup);

    // roof tiles (grid)
    const roofGroup = new THREE.Group();
    const tilesX = 6, tilesZ = 4;
    for(let tx=0; tx<tilesX; tx++){
      for(let tz=0; tz<tilesZ; tz++){
        const tile = new THREE.Mesh(new THREE.BoxGeometry(4, 1.8, 6), new THREE.MeshStandardMaterial({ color: 0x6b1616 }));
        tile.position.set((tx-(tilesX-1)/2)*4.2, h+1.6 + Math.random()*0.2, (tz-(tilesZ-1)/2)*6.2);
        tile.rotation.y = Math.random()*0.02;
        tile.userData.isRoofTile = true;
        roofGroup.add(tile);
      }
    }
    roofGroup.position.y = 0;
    house.add(roofGroup);

    // store meta
    house.userData = {
      baseGroup, roofGroup,
      position: null,
      removedCount:0,
      damageAccum:0
    };

    // position house
    house.position.set((Math.random()-0.5)*1400, 0, (Math.random()-0.5)*1400);
    house.userData.position = house.position.clone();
    scene.add(house);
    houses.push(house);
  }

  // Trees (stacked cones)
  for(let i=0;i<treeCount;i++){
    const tree = new THREE.Group();
    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.9,1.2,5,8), new THREE.MeshStandardMaterial({ color:0x6b3f2a }));
    trunk.position.y = 2.5;
    tree.add(trunk);
    const foliageGroup = new THREE.Group();
    const layers = performanceMode ? 2 : 4;
    for(let l=0;l<layers;l++){
      const cone = new THREE.Mesh(new THREE.ConeGeometry(3 + l*1.2, 6 + l*1.2, 8), new THREE.MeshStandardMaterial({ color:0x1f7a1f }));
      cone.position.y = 6 + l*2.8;
      foliageGroup.add(cone);
    }
    tree.add(foliageGroup);
    tree.userData = { trunk, foliageGroup, damageAccum:0, removedParts:[] };
    tree.position.set((Math.random()-0.5)*1400, 0, (Math.random()-0.5)*1400);
    scene.add(tree);
    trees.push(tree);
  }

  // ambient debris
  for(let i=0;i<ambientDebris;i++){
    const size = 0.6 + Math.random()*2.4;
    const geo = new THREE.BoxGeometry(size, Math.max(0.2,size*0.35), size*0.7);
    const mat = new THREE.MeshStandardMaterial({ color: 0x7b7b7b });
    const piece = new THREE.Mesh(geo, mat);
    piece.position.set((Math.random()-0.5)*900, Math.random()*120 + 5, (Math.random()-0.5)*900);
    piece.userData = { velocity: new THREE.Vector3() };
    debrisGroup.add(piece);
    debrisPieces.push(piece);
  }

  // set small visual scale according to tornadoWidth
  adjustTornadoVisualScale();
  updateWindRadius();
}

// adjust visual scale of funnel to not explode scene
function adjustTornadoVisualScale(){
  const visualScale = Math.max(0.6, Math.min(3.0, tornadoWidth / 50));
  tornado.scale.set(visualScale, 1, visualScale);
  // adjust inner particle bounding spread
  const posAttr = funnelInnerParticles.geometry.attributes.position;
  for(let i=0;i<posAttr.count;i++){
    const ix = i*3;
    // re-randomize positions lightly to scale spread
    posAttr.array[ix+0] = (Math.random()-0.5) * 30 * visualScale;
    posAttr.array[ix+1] = Math.random() * 220;
    posAttr.array[ix+2] = (Math.random()-0.5) * 30 * visualScale;
  }
  posAttr.needsUpdate = true;
}

// compute tornadoWindRadius from width and wind speed
function updateWindRadius(){
  tornadoWindRadius = Math.max(80, tornadoWidth * 3 * (windSpeed/80 + 0.6));
}

// === spawn debris from removed part ===
function spawnDebrisFromMesh(mesh, count=4){
  const worldPos = new THREE.Vector3();
  mesh.getWorldPosition(worldPos);
  for(let i=0;i<count;i++){
    const s = 0.6 + Math.random()*2.2;
    const geo = new THREE.BoxGeometry(s, Math.max(0.2,s*0.3), s*0.7);
    const mat = new THREE.MeshStandardMaterial({ color: mesh.material && mesh.material.color ? mesh.material.color.clone() : 0x7b7b7b });
    const p = new THREE.Mesh(geo, mat);
    p.position.copy(worldPos).add(new THREE.Vector3((Math.random()-0.5)*6, 2 + Math.random()*3, (Math.random()-0.5)*6));
    p.userData = { velocity: new THREE.Vector3((Math.random()-0.5)*2, 2 + Math.random()*3, (Math.random()-0.5)*2), life: 10 + Math.random()*8 };
    debrisGroup.add(p);
    debrisPieces.push(p);
    if(debrisPieces.length > (performanceMode ? 700 : 1800)) break;
  }
}

// remove a child safely and spawn debris
function removeChildAndSpawn(parent, child){
  if(parent && child){
    const world = new THREE.Vector3();
    child.getWorldPosition(world);
    parent.remove(child);
    spawnDebrisFromMesh(child, 3 + Math.floor(Math.random()*4));
  }
}

// === damage & debris physics ===
function applyDamageAndDebrisPhysics(delta){
  const tornadoCenter = new THREE.Vector3(tornado.position.x, 60, tornado.position.z);

  // Houses: continuous damage while windSpeed >= damageThreshold
  houses.forEach(h=>{
    const dist = h.position.distanceTo(tornadoCenter);
    const proximity = Math.max(0, 1 - dist / tornadoWindRadius);
    if(windSpeed >= damageThreshold && proximity > 0.02){
      // intensity scales with wind & proximity
      const intensity = ((windSpeed - damageThreshold) / (200 - damageThreshold + 0.0001)) * proximity;
      h.userData.damageAccum = (h.userData.damageAccum || 0) + intensity * delta * (1.0 + Math.random()*0.8);
      // when accumulated, remove a random roof tile or a wall brick
      if(h.userData.damageAccum > 0.6){
        // pick random from roof first
        const roof = h.userData.roofGroup;
        if(roof && roof.children.length > 0){
          const idx = Math.floor(Math.random() * roof.children.length);
          const tile = roof.children[idx];
          removeChildAndSpawn(roof, tile);
        } else {
          // remove a random brick from baseGroup
          const base = h.userData.baseGroup;
          if(base && base.children.length > 0){
            const idx = Math.floor(Math.random() * base.children.length);
            const brick = base.children[idx];
            removeChildAndSpawn(base, brick);
          }
        }
        // reset accumulation to randomized small so removals are staggered
        h.userData.damageAccum = Math.random()*0.25;
      }
    } else {
      // slow recovery when winds drop below threshold
      h.userData.damageAccum = Math.max(0, (h.userData.damageAccum||0) - delta*0.2);
    }
  });

  // Trees
  trees.forEach(t=>{
    const dist = t.position.distanceTo(tornadoCenter);
    const proximity = Math.max(0, 1 - dist / (tornadoWindRadius * 0.9));
    if(windSpeed >= damageThreshold && proximity > 0.02){
      const intensity = ((windSpeed - damageThreshold) / (200 - damageThreshold + 0.0001)) * proximity;
      t.userData.damageAccum = (t.userData.damageAccum || 0) + intensity * delta * (1.2 + Math.random()*0.6);
      if(t.userData.damageAccum > 0.45){
        const foliage = t.userData.foliageGroup;
        if(foliage && foliage.children.length > 0){
          const idx = Math.floor(Math.random()*foliage.children.length);
          const piece = foliage.children[idx];
          removeChildAndSpawn(foliage, piece);
        } else {
          // remove trunk collapse
          const trunk = t.userData.trunk;
          if(trunk && trunk.parent){
            removeChildAndSpawn(t, trunk);
          }
        }
        t.userData.damageAccum = Math.random()*0.2;
      }
    } else {
      t.userData.damageAccum = Math.max(0, (t.userData.damageAccum||0) - delta*0.18);
    }
  });

  // Debris physics: swirl + suction
  const time = performance.now() * 0.001;
  const maxPull = tornadoWindRadius * 1.6;
  for(let i=debrisPieces.length-1;i>=0;i--){
    const p = debrisPieces[i];
    // lifetime removal
    if(p.userData.life !== undefined){
      p.userData.life -= delta;
      if(p.userData.life <= 0){
        debrisGroup.remove(p);
        debrisPieces.splice(i,1);
        continue;
      }
    }
    // compute vector to tornado center
    const dir = new THREE.Vector3().subVectors(tornadoCenter, p.position);
    const dist = dir.length();
    // if far: gentle settle
    if(dist > maxPull){
      p.userData.velocity.y -= 9.8 * 0.018 * delta;
      p.userData.velocity.multiplyScalar(0.995);
      p.position.addScaledVector(p.userData.velocity, delta * 60);
      continue;
    }
    const radial = dir.clone().normalize();
    const tangential = new THREE.Vector3(-radial.z, 0, radial.x);
    const proximity = Math.max(0, 1 - dist / maxPull);
    const pull = 0.9 * (windSpeed / 140) * proximity;
    const swirl = 0.45 * (1 + proximity*1.8) * (windSpeed / 160);
    const up = 0.6 * (1 + proximity) * (windSpeed / 200);
    const wobble = Math.sin(time * 6 + i) * 0.02;
    p.userData.velocity.addScaledVector(radial, pull * delta * 200);
    p.userData.velocity.addScaledVector(tangential, swirl * delta * 200);
    p.userData.velocity.y += (up + wobble) * delta * 60;
    p.userData.velocity.multiplyScalar(0.994);
    p.position.addScaledVector(p.userData.velocity, delta * 60);
    // ingest when close
    if(dist < 8){
      if(Math.random() < 0.25){
        p.userData.life = 3 + Math.random()*4;
      } else {
        debrisGroup.remove(p);
        debrisPieces.splice(i,1);
      }
    }
  }
}

// === lightning from storm to ground ===
function maybeLightning(delta){
  lightningTimer -= delta;
  if(lightningTimer <= 0){
    lightningTimer = 0.6 + Math.random()*3.2;
    if(Math.random() < 0.5){
      createLightning();
    }
  }
}
function createLightning(){
  const origin = new THREE.Vector3(
    tornado.position.x + (Math.random()-0.5)*300,
    180 + Math.random()*80,
    tornado.position.z + (Math.random()-0.5)*300
  );
  const target = new THREE.Vector3(
    tornado.position.x + (Math.random()-0.5)*800,
    0,
    tornado.position.z + (Math.random()-0.5)*800
  );
  const segments = 10;
  const pts = [];
  for(let i=0;i<=segments;i++){
    const t = i/segments;
    const y = origin.y * (1 - t);
    const x = origin.x + (target.x - origin.x)*t + (Math.random()-0.5)*60*(1-t);
    const z = origin.z + (target.z - origin.z)*t + (Math.random()-0.5)*60*(1-t);
    pts.push(new THREE.Vector3(x,y,z));
  }
  const geo = new THREE.BufferGeometry().setFromPoints(pts);
  const mat = new THREE.LineBasicMaterial({ color:0xffffff, linewidth:2 });
  const bolt = new THREE.Line(geo, mat);
  scene.add(bolt);
  const flash = new THREE.PointLight(0xffffff, 3.2, 1600);
  flash.position.copy(target).add(new THREE.Vector3(0,40,0));
  scene.add(flash);
  setTimeout(()=>{ scene.remove(bolt); scene.remove(flash); }, 100 + Math.random()*160);
}

// === funnel drop & start ===
function startDrop(){
  if(dropping || animating) return;
  // begin drop animation: start tornado up high
  tornado.position.set(tornadoStart.x, tornadoStart.y, tornadoStart.z);
  dropping = true;
  animating = false;
  const dropDuration = 1600; // ms
  const startY = tornadoStart.y;
  const endY = 60; // when touches ground visually (base near y=0)
  const start = performance.now();
  (function dropStep(now){
    const t = Math.min(1, (now - start) / dropDuration);
    // easeOutCubic
    const e = 1 - Math.pow(1 - t, 3);
    tornado.position.y = startY * (1 - e) + endY * e;
    // rotate rings faster during drop for effect
    tornado.children.forEach((r, idx)=> r.rotation.y += 0.03 + idx*0.001);
    if(t < 1){
      requestAnimationFrame(dropStep);
    } else {
      // landed â€” settle
      dropping = false;
      animating = true; // now start moving forward
    }
  })(performance.now());
}

// === reset everything ===
function resetAll(){
  animating = false; dropping = false;
  // reset tornado pos & scale
  tornado.position.set(tornadoStart.x, tornadoStart.y, tornadoStart.z);
  tornado.rotation.set(0,0,0);
  tornado.scale.set(1,1,1);
  // clear objects
  houses.forEach(h=>scene.remove(h)); houses = [];
  trees.forEach(t=>scene.remove(t)); trees = [];
  debrisPieces.forEach(d=>debrisGroup.remove(d)); debrisPieces = [];
  // clear scour
  const ctx = scourCanvas.getContext('2d');
  ctx.clearRect(0,0,scourCanvas.width,scourCanvas.height);
  scourTexture.needsUpdate = true;
  // recreate
  recreateSceneObjects();
}

// === recreate helper ===
function recreateSceneObjects(){
  applyPerformanceMode();
  recreateSceneObjectsInternal();
}
function recreateSceneObjectsInternal(){
  // just call the earlier recreate function: name collision avoided by wrapper
  recreateSceneObjects(); // but we must avoid recursion â€” create wrapper with different name
}

// Fix accidental recursion: rename internal functions properly
// We'll simply call the main recreate function directly by renaming below.
// (Because of scope above, let's implement the actual recreate now.)
function recreateSceneObjects(){
  // remove existing
  houses.forEach(h=>scene.remove(h)); houses.length = 0;
  trees.forEach(t=>scene.remove(t)); trees.length = 0;
  debrisPieces.forEach(d=>debrisGroup.remove(d)); debrisPieces.length = 0;
  // create objects fresh
  // (reuse the earlier recreateSceneObjects logic inline to avoid naming confusion)
  const houseCount = performanceMode ? 8 : 20;
  const treeCount  = performanceMode ? 28 : 80;
  const ambientDebris = performanceMode ? 60 : 220;

  // Houses
  for(let i=0;i<houseCount;i++){
    const house = new THREE.Group();
    const baseGroup = new THREE.Group();
    const w = 18, h = 10, d = 14;
    const brickSize = 3;
    const xCount = Math.max(2, Math.floor(w/brickSize));
    const zCount = Math.max(2, Math.floor(d/brickSize));
    for(let xi=0; xi<xCount; xi++){
      for(let zi=0; zi<zCount; zi++){
        const brick = new THREE.Mesh(new THREE.BoxGeometry(brickSize, h-2, brickSize),
          new THREE.MeshStandardMaterial({ color: 0xb76a3a }));
        brick.position.set((xi - (xCount-1)/2) * brickSize, (h/2)-1, (zi - (zCount-1)/2)*brickSize);
        baseGroup.add(brick);
      }
    }
    baseGroup.position.y = 0;
    house.add(baseGroup);

    // roof group
    const roofGroup = new THREE.Group();
    const tilesX = 6, tilesZ = 4;
    for(let tx=0; tx<tilesX; tx++){
      for(let tz=0; tz<tilesZ; tz++){
        const tile = new THREE.Mesh(new THREE.BoxGeometry(4, 1.8, 6),
          new THREE.MeshStandardMaterial({ color: 0x6b1616 }));
        tile.position.set((tx-(tilesX-1)/2)*4.2, h+1.6 + Math.random()*0.2, (tz-(tilesZ-1)/2)*6.2);
        tile.rotation.y = Math.random()*0.03;
        roofGroup.add(tile);
      }
    }
    house.add(roofGroup);

    house.userData = { baseGroup, roofGroup, damageAccum:0 };

    house.position.set((Math.random()-0.5)*1400, 0, (Math.random()-0.5)*1400);
    scene.add(house);
    houses.push(house);
  }

  // Trees
  for(let i=0;i<treeCount;i++){
    const tree = new THREE.Group();
    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.95,1.15,5,8),
      new THREE.MeshStandardMaterial({ color:0x6b3f2a }));
    trunk.position.y = 2.5;
    tree.add(trunk);
    const foliage = new THREE.Group();
    const layers = performanceMode ? 2 : 4;
    for(let l=0;l<layers;l++){
      const cone = new THREE.Mesh(new THREE.ConeGeometry(3 + l*1.2, 6 + l*1.2, 8),
        new THREE.MeshStandardMaterial({ color:0x1f7a1f }));
      cone.position.y = 6 + l*2.8;
      foliage.add(cone);
    }
    tree.add(foliage);
    tree.userData = { trunk, foliageGroup:foliage, damageAccum:0 };
    tree.position.set((Math.random()-0.5)*1400, 0, (Math.random()-0.5)*1400);
    scene.add(tree);
    trees.push(tree);
  }

  // ambient debris
  for(let i=0;i<ambientDebris;i++){
    const size = 0.6 + Math.random()*2.4;
    const geo = new THREE.BoxGeometry(size, Math.max(0.2,size*0.35), size*0.7);
    const mat = new THREE.MeshStandardMaterial({ color: 0x7b7b7b });
    const piece = new THREE.Mesh(geo, mat);
    piece.position.set((Math.random()-0.5)*900, Math.random()*120 + 5, (Math.random()-0.5)*900);
    piece.userData = { velocity: new THREE.Vector3() };
    debrisGroup.add(piece);
    debrisPieces.push(piece);
  }

  // reset visual funnel & wind radius
  adjustTornadoVisualScale();
  updateWindRadius();
}

// === main loop ===
function animate(){
  requestAnimationFrame(animate);
  const now = performance.now();
  const delta = Math.min(0.05, (now - lastT)/1000);
  lastT = now;

  // If animating and not dropping, move tornado forward
  if(animating && !dropping){
    const speedUnits = tornadoSpeedMph * 0.06;
    tornado.position.x += speedUnits * delta * 60;
    // rotate rings faster if winds stronger
    tornado.children.forEach((r, idx)=>{
      r.rotation.y += 0.02 + (windSpeed/220) * (0.08 + idx*0.001);
    });
    // inner particles spin
    funnelInnerParticles.rotation.y += 0.08 + windSpeed/500;
  } else {
    // even if not moving, spin slightly for realism
    tornado.children.forEach((r, idx)=> r.rotation.y += 0.006 + idx*0.0001);
    funnelInnerParticles.rotation.y += 0.002;
  }

  // supercell rotates slowly across whole map
  supercell.rotation.y += 0.0008 * (performanceMode ? 0.5 : 1.0) * (1 + windSpeed/200);
  // wall cloud follows tornado closely
  wallCloud.position.lerp(new THREE.Vector3(tornado.position.x, tornado.position.y + 30, tornado.position.z), 0.06);

  // paint scour overlay each frame to reflect current tornado pos & wind
  paintScourTexture();

  // apply damage + debris physics only when animating (tornado present)
  if(animating){
    applyDamageAndDebrisPhysics(delta);
  } else {
    // still update debris physics slowly to settle
    for(let i=debrisPieces.length-1;i>=0;i--){
      const p = debrisPieces[i];
      p.userData.velocity.y -= 9.8 * 0.018 * delta;
      p.userData.velocity.multiplyScalar(0.995);
      p.position.addScaledVector(p.userData.velocity, delta * 60);
      if(p.userData.life !== undefined){
        p.userData.life -= delta;
        if(p.userData.life <= 0){
          debrisGroup.remove(p);
          debrisPieces.splice(i,1);
        }
      }
    }
  }

  // lightning
  maybeLightning(delta);

  renderer.render(scene, camera);
}

</script>
</body>
</html>
