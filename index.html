<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Advanced 3D Tornado Simulator</title>
<style>
  body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
  #controls {
    position: absolute; top: 10px; left: 10px; background: rgba(255,255,255,0.9);
    padding: 10px; border-radius: 8px; z-index: 10; max-width: 250px;
  }
  #controls input { width: 160px; }
  button { margin: 5px 0; padding: 5px 10px; }
</style>
</head>
<body>
<div id="controls">
  <label>Wind Speed (mph): <span id="windValue">50</span></label><br />
  <input type="range" id="windSlider" min="10" max="200" value="50"><br />

  <label>Tornado Speed (mph): <span id="speedValue">20</span></label><br />
  <input type="range" id="speedSlider" min="1" max="90" value="20"><br />

  <label>Tornado Width: <span id="widthValue">50</span></label><br />
  <input type="range" id="widthSlider" min="10" max="250" value="50"><br />

  <label>Performance Mode:</label>
  <input type="checkbox" id="perfToggle" checked><br>

  <button id="startBtn">Start</button>
  <button id="resetBtn">Reset</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script>
let scene, camera, renderer;
let tornado, debrisGroup = [], debrisParticles = [];
let houses = [], trees = [];
let supercell, wallCloud;
let animating = false;
let windSpeed = 50, tornadoSpeed = 20, tornadoWidth = 50;
let performanceMode = true;
let lightningCooldown = 0;

// UI Elements
const windSlider = document.getElementById("windSlider");
const speedSlider = document.getElementById("speedSlider");
const widthSlider = document.getElementById("widthSlider");
const windValue = document.getElementById("windValue");
const speedValue = document.getElementById("speedValue");
const widthValue = document.getElementById("widthValue");
const perfToggle = document.getElementById("perfToggle");

windSlider.oninput = ()=> { windValue.textContent = windSlider.value; windSpeed = Number(windSlider.value); };
speedSlider.oninput = ()=> { speedValue.textContent = speedSlider.value; tornadoSpeed = Number(speedSlider.value)/10; };
widthSlider.oninput = ()=> { 
  widthValue.textContent = widthSlider.value; 
  tornadoWidth = Number(widthSlider.value); 
};
perfToggle.onchange = ()=> { performanceMode = perfToggle.checked; setupSceneObjects(); };

// Init scene
init();
animate();

function init(){
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);

  camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 5000);
  camera.position.set(0, 200, 400);
  camera.lookAt(0,0,0);

  renderer = new THREE.WebGLRenderer({ antialias: !performanceMode });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Lights
  const hemiLight = new THREE.HemisphereLight(0xffffff,0x444444,1);
  scene.add(hemiLight);
  const dirLight = new THREE.DirectionalLight(0xffffff,0.8);
  dirLight.position.set(-100,200,100);
  scene.add(dirLight);

  // Ground
  const groundMat = new THREE.MeshPhongMaterial({color:0x228B22});
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(2000,2000), groundMat);
  ground.rotation.x = -Math.PI/2;
  scene.add(ground);

  // Tornado
  const torGeo = new THREE.CylinderGeometry(20,5,120,16,1,true);
  const torMat = new THREE.MeshStandardMaterial({color:0x555555, transparent:true, opacity:0.7});
  tornado = new THREE.Mesh(torGeo, torMat);
  tornado.position.set(-400,60,0);
  scene.add(tornado);

  // Debris group
  debrisGroup = new THREE.Group();
  scene.add(debrisGroup);

  // Supercell & Wall cloud
  supercell = new THREE.Group();
  wallCloud = new THREE.Group();
  scene.add(supercell);
  scene.add(wallCloud);

  // Supercell mesh
  const supercellMesh = new THREE.Mesh(
    new THREE.SphereGeometry(100,16,16),
    new THREE.MeshStandardMaterial({color:0x555555, transparent:true, opacity:0.3})
  );
  supercell.add(supercellMesh);
  const wallCloudMesh = new THREE.Mesh(
    new THREE.SphereGeometry(60,16,16),
    new THREE.MeshStandardMaterial({color:0x333333, transparent:true, opacity:0.4})
  );
  wallCloud.add(wallCloudMesh);

  // Buttons
  document.getElementById("startBtn").onclick = ()=> { animating=true; };
  document.getElementById("resetBtn").onclick = ()=> { animating=false; resetAll(); };

  window.addEventListener("resize",()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  setupSceneObjects();
}

// Setup houses, trees, debris
function setupSceneObjects(){
  // Clear previous
  houses.forEach(h=>scene.remove(h));
  trees.forEach(t=>scene.remove(t));
  debrisParticles.forEach(d=>debrisGroup.remove(d));
  houses=[]; trees=[]; debrisParticles=[];

  let houseCount = performanceMode ? 10 : 20;
  let treeCount = performanceMode ? 20 : 50;
  let debrisCount = performanceMode ? 50 : 200;

  // Houses
  for(let i=0;i<houseCount;i++){
    let house = new THREE.Group();
    let base = new THREE.Mesh(new THREE.BoxGeometry(20,10,20), new THREE.MeshStandardMaterial({color:0xa0522d}));
    let roof = new THREE.Mesh(new THREE.ConeGeometry(15,6,4), new THREE.MeshStandardMaterial({color:0x8b0000}));
    roof.position.y=8;
    house.add(base); house.add(roof);
    house.position.set((Math.random()-0.5)*1500,5,(Math.random()-0.5)*1500);
    house.userData.original = {pos: house.position.clone(), rotation: house.rotation.clone(), children: house.children.map(c=>c.clone())};
    house.userData.damagedParts = [];
    scene.add(house);
    houses.push(house);
  }

  // Trees
  for(let i=0;i<treeCount;i++){
    let trunk = new THREE.Mesh(new THREE.CylinderGeometry(1,1,5,6), new THREE.MeshStandardMaterial({color:0x8b4513}));
    let leaves = new THREE.Mesh(new THREE.ConeGeometry(3,10,8), new THREE.MeshStandardMaterial({color:0x228B22}));
    let tree = new THREE.Group();
    trunk.position.y=2.5; leaves.position.y=8;
    tree.add(trunk); tree.add(leaves);
    tree.position.set((Math.random()-0.5)*1500,0,(Math.random()-0.5)*1500);
    tree.userData.original = {pos: tree.position.clone(), children: tree.children.map(c=>c.clone())};
    tree.userData.damagedParts=[];
    scene.add(tree);
    trees.push(tree);
  }

  // Debris
  for(let i=0;i<debrisCount;i++){
    let d = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({color:0x888888}));
    d.position.set((Math.random()-0.5)*800,Math.random()*100,(Math.random()-0.5)*800);
    d.userData.velocity = new THREE.Vector3();
    debrisGroup.add(d);
    debrisParticles.push(d);
  }
}

// Reset everything
function resetAll(){
  houses.forEach(h=>{
    h.position.copy(h.userData.original.pos);
    h.rotation.copy(h.userData.original.rotation);
    h.children.forEach((c,i)=>{
      let original = h.userData.original.children[i];
      c.geometry.copy(original.geometry);
      c.material.color.copy(original.material.color);
    });
    h.userData.damagedParts=[];
  });
  trees.forEach(t=>{
    t.position.copy(t.userData.original.pos);
    t.children.forEach((c,i)=>{
      let original = t.userData.original.children[i];
      c.geometry.copy(original.geometry);
      c.material.color.copy(original.material.color);
    });
    t.userData.damagedParts=[];
  });
  debrisParticles.forEach(d=>debrisGroup.remove(d));
  debrisParticles=[];
  setupSceneObjects();
}

// Spawn debris from destroyed object
function spawnDebrisFromObject(obj){
  obj.children.forEach(p=>{
    if(Math.random()<0.5){
      let d = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({color:p.material.color}));
      d.position.copy(p.getWorldPosition(new THREE.Vector3()));
      d.userData.velocity = new THREE.Vector3((Math.random()-0.5)*0.5,Math.random()*0.5,(Math.random()-0.5)*0.5);
      debrisGroup.add(d); debrisParticles.push(d);
    }
  });
}

// Animate loop
function animate(){
  requestAnimationFrame(animate);

  if(animating){
    // Tornado movement
    tornado.position.x += tornadoSpeed;
    tornado.rotation.y += 0.05;

    let tornadoWindRadius = tornadoWidth*2;

    // Houses damage
    houses.forEach(h=>{
      let dist = h.position.distanceTo(tornado.position);
      if(dist < tornadoWindRadius){
        let chance = Math.random()*windSpeed;
        h.children.forEach(c=>{
          if(chance>40 && !h.userData.damagedParts.includes(c)){
            c.position.y -= Math.random()*1;
            c.rotation.x += (Math.random()-0.5)*0.3;
            c.rotation.z += (Math.random()-0.5)*0.3;
            h.userData.damagedParts.push(c);
            spawnDebrisFromObject(h);
          }
        });
      }
    });

    // Trees damage
    trees.forEach(t=>{
      let dist = t.position.distanceTo(tornado.position);
      if(dist < tornadoWindRadius){
        let chance = Math.random()*windSpeed;
        t.children.forEach(c=>{
          if(chance>30 && !t.userData.damagedParts.includes(c)){
            c.rotation.x += (Math.random()-0.5)*0.5;
            c.rotation.z += (Math.random()-0.5)*0.5;
            t.userData.damagedParts.push(c);
            spawnDebrisFromObject(t);
          }
        });
      }
    });

    // Debris movement
    debrisParticles.forEach(d=>{
      let dir = new THREE.Vector3().subVectors(tornado.position,d.position);
      let dist = dir.length();
      if(dist < tornadoWindRadius*2){
        dir.normalize();
        let strength = (windSpeed/50)*(1 - dist/(tornadoWindRadius*2));
        d.userData.velocity.add(new THREE.Vector3(Math.sin(Date.now()*0.001)*0.02,0.05,Math.cos(Date.now()*0.001)*0.02));
        d.userData.velocity.add(dir.multiplyScalar(0.3*strength));
        d.position.add(d.userData.velocity);
      }
    });

    // Lightning
    lightningCooldown--;
    if(lightningCooldown<=0 && Math.random()<0.01){
      lightningCooldown = 60+Math.random()*100;
      const lightning = new THREE.DirectionalLight(0xffffff,1);
      lightning.position.set(Math.random()*500-250,300,Math.random()*500-250);
      scene.add(lightning);
      setTimeout(()=>scene.remove(lightning),100);
    }

    // Supercell & Wall cloud
    supercell.position.set(tornado.position.x,120,tornado.position.z);
    wallCloud.position.set(tornado.position.x,100,tornado.position.z);
  }

  renderer.render(scene,camera);
}
</script>
</body>
</html>
